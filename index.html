<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Калькулятор Ограждений</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/0.1.0/dom-to-image.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        /* Ночной режим */
        body.night-mode {
            background: #1a1a2e;
        }

        #app {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        /* Левая панель */
        .sidebar {
            width: 320px;
            background: white;
            border-right: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }
        
        /* Ночной режим для сайдбара */
        body.night-mode .sidebar {
            background: #2c2c2c;
            border-right-color: #444;
        }
        
        /* Верхние кнопки управления */
        .top-controls {
            padding: 15px;
            border-bottom: 1px solid #444; /* как подвал */
            background: #2c2c2c; /* графитовый фон как подвал */
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .top-controls button {
            padding: 8px 14px;
            border: 1px solid #bfc3c9;
            background: #e9eaee;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            color: #2c2c2c;
            font-weight: 600;
            width: auto;
        }
        
        .top-controls button:hover {
            background: #dfe1e6;
            border-color: #b0b4bb;
        }
        
        /* Панель инструментов */
        .toolbar {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .toolbar h3 {
            color: #ff6600;
            margin-bottom: 15px;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        /* Ночной режим для заголовков */
        body.night-mode .toolbar h3 {
            color: #ff8533;
        }
        
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .tool-button {
            width: 60px;
            height: 60px;
            border: 2px solid #ff6600;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .tool-button:hover {
            background: linear-gradient(135deg, #ff6600 0%, #ff8533 50%, #ff6600 100%);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 102, 0, 0.4);
        }
        
        .tool-button.active {
            background: linear-gradient(135deg, #ff6600 0%, #ff8533 50%, #ff6600 100%);
            box-shadow: 0 2px 8px rgba(255, 102, 0, 0.3);
        }
        
        .tool-button img {
            width: 32px;
            height: 32px;
            transition: all 0.3s;
            filter: brightness(0.7);
        }
        
        .tool-button:hover img {
            filter: brightness(0) invert(1);
            transform: scale(1.1);
        }
        
        .tool-button.active img {
            filter: brightness(0) invert(1);
        }
        
        /* Секция добавления пролета */
        .add-span-section {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .add-span-section h3 {
            color: #ff6600;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .form-group input[readonly] {
            background: #f5f5f5;
            cursor: not-allowed;
        }
        
        .add-button {
            width: 100%;
            padding: 12px;
            background: #ff6600;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background 0.3s;
        }
        
        .add-button:hover {
            background: #e55a00;
        }
        
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
            display: inline-block;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        
        .btn-success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }
        
        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        /* Центральная область */
        .main-canvas {
            flex: 1;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 50%, #4682B4 100%);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            perspective: 1200px; /* для 3D */
        }
        
        /* Ночной режим для основного canvas */
        body.night-mode .main-canvas {
            background: linear-gradient(to bottom, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }
        

        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .main-canvas {
            cursor: grab;
        }
        
        .main-canvas:active {
            cursor: grabbing;
        }
        
        .canvas-controls {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .zoom-indicator {
            position: absolute;
            top: 30px;
            right: 150px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        
        .canvas-controls .btn {
            padding: 8px 12px;
            font-size: 12px;
            min-width: 80px;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .info-item {
            text-align: center;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }
        
        .info-item h4 {
            color: #667eea;
            margin-bottom: 5px;
        }
        
        .info-item .value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
        }
        
        .info-item .unit {
            color: #666;
            font-size: 0.9rem;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .control-panel {
                order: 2;
            }
            
            .canvas-container {
                order: 1;
                height: 500px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .control-panel {
                padding: 20px;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                margin: 5px 0;
            }
        }
        
        /* Нижняя панель */
        .bottom-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background: #2c2c2c;
            border-top: 2px solid #444;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        
        .info-display {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: white;
            flex: 1;
            justify-content: center;
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .info-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 2px;
        }
        
        .info-value {
            font-weight: 500;
            color: white;
        }
        
        .right-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .calculate-button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(255, 102, 0, 0.3);
        }
        
        .calculate-button:hover {
            background: #e55a00;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 102, 0, 0.4);
        }
        
        .copyright {
            font-size: 12px;
            color: #aaa;
        }
        
        /* Переключатель день/ночь */
        .day-night-switch {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .zoom-indicator {
            position: fixed;
            top: 20px;
            right: 100px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(102, 126, 234, 0.2);
            transition: all 0.3s ease;
        }
        
        /* Ночной режим для индикатора масштаба */
        body.night-mode .zoom-indicator {
            background: rgba(40, 40, 40, 0.9);
            color: #fff;
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .switch-button {
            width: 60px;
            height: 60px;
            background: #4682B4;
            border: 2px solid #4682B4;
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
        }
        
        .switch-button.night-mode {
            background: #4B0082;
            border-color: #4B0082;
        }
        
        .switch-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }
        
        /* Стили для столбов */
        .fence-post {
            width: 50px;
            height: 80px;
            margin: 0 2px;
            position: relative;
            overflow: hidden;
        }
        
        /* Стили для новых столбов, созданных кликом */
        .fence-post[style*="position: absolute"] {
            margin: 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .fence-post[style*="position: absolute"]:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        /* Стиль для выбранного столба */
        .fence-post.selected {
            position: relative;
        }
        
        /* Стиль для полоски выделения */
        .selection-highlight {
            position: absolute;
            bottom: -5px;
            left: -7px;
            right: -7px;
            height: 4px;
            background: linear-gradient(to right, 
                rgba(255, 165, 0, 0) 0%, 
                rgba(255, 140, 0, 0.9) 15%, 
                rgba(255, 215, 0, 1) 30%, 
                rgba(255, 165, 0, 1) 50%, 
                rgba(255, 140, 0, 1) 70%, 
                rgba(255, 140, 0, 0.9) 85%, 
                rgba(255, 165, 0, 0) 100%);
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(255, 165, 0, 0.6), 0 0 16px rgba(255, 215, 0, 0.4);
            z-index: 200;
            pointer-events: none;
        }
        
        /* Стили для пролётов */
        .fence-span {
            position: absolute;
            background: #555; /* Тёмно-серое заполнение по умолчанию */
            cursor: pointer;
            z-index: 150; /* Увеличиваем z-index выше внутренних элементов */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #333;
            font-weight: bold;
        }
        
        .fence-span:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .fence-span.selected {
            position: relative;
        }
        
        /* Стили для ворот */
        .fence-gate {
            position: absolute;
            background: #555; /* Тёмно-серое заполнение по умолчанию */
            cursor: pointer;
            z-index: 150; /* Увеличиваем z-index */
        }
        
        .fence-gate.selected {
            position: relative;
        }
        
        /* Стили для калиток */
        .fence-wicket {
            position: absolute;
            background: #555; /* Тёмно-серое заполнение по умолчанию */
            cursor: pointer;
            z-index: 150; /* Увеличиваем z-index */
        }
        
        .fence-wicket.selected {
            position: relative;
        }
        
        .fence-block {
            width: 50px; /* 0.5м = 50px */
            height: 20px; /* 0.2м = 20px */
            background-size: 150px 60px; /* 3x3 сетка текстур */
            background-repeat: no-repeat;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            display: block;
            pointer-events: none; /* Не блокируем клики по основному элементу */
        }
        
        /* Стили для блоков с текстурами (3x3 сетка) */
        .fence-block:nth-child(1) { background-position: 0 0; }
        .fence-block:nth-child(2) { background-position: -50px 0; }
        .fence-block:nth-child(3) { background-position: -100px 0; }
        .fence-block:nth-child(4) { background-position: -150px 0; }
        .fence-block:nth-child(5) { background-position: -200px 0; }
        .fence-block:nth-child(6) { background-position: -250px 0; }
        .fence-block:nth-child(7) { background-position: -300px 0; }
        .fence-block:nth-child(8) { background-position: -350px 0; }
        .fence-block:nth-child(9) { background-position: -400px 0; }
        
        .fence-block:nth-child(10) { background-position: 0 -20px; }
        .fence-block:nth-child(11) { background-position: -50px -20px; }
        .fence-block:nth-child(12) { background-position: -100px -20px; }
        .fence-block:nth-child(13) { background-position: -150px -20px; }
        .fence-block:nth-child(14) { background-position: -200px -20px; }
        .fence-block:nth-child(15) { background-position: -250px -20px; }
        .fence-block:nth-child(16) { background-position: -300px -20px; }
        .fence-block:nth-child(17) { background-position: -350px -20px; }
        .fence-block:nth-child(18) { background-position: -400px -20px; }
        
        .fence-block:nth-child(19) { background-position: 0 -40px; }
        .fence-block:nth-child(20) { background-position: -50px -40px; }
        .fence-block:nth-child(21) { background-position: -100px -40px; }
        .fence-block:nth-child(22) { background-position: -150px -40px; }
        .fence-block:nth-child(23) { background-position: -200px -40px; }
        .fence-block:nth-child(24) { background-position: -250px -40px; }
        .fence-block:nth-child(25) { background-position: -300px -40px; }
        .fence-block:nth-child(26) { background-position: -350px -40px; }
        .fence-block:nth-child(27) { background-position: -400px -40px; }
        
        .fence-block:nth-child(28) { background-position: 0 -60px; }
        .fence-block:nth-child(29) { background-position: -50px -60px; }
        .fence-block:nth-child(30) { background-position: -100px -60px; }
        .fence-block:nth-child(31) { background-position: -150px -60px; }
        .fence-block:nth-child(32) { background-position: -200px -60px; }
        .fence-block:nth-child(33) { background-position: -250px -60px; }
        .fence-block:nth-child(34) { background-position: -300px -60px; }
        .fence-block:nth-child(35) { background-position: -350px -60px; }
        .fence-block:nth-child(36) { background-position: -400px -60px; }
        
        .fence-block:nth-child(37) { background-position: 0 -80px; }
        .fence-block:nth-child(38) { background-position: -50px -80px; }
        .fence-block:nth-child(39) { background-position: -100px -80px; }
        .fence-block:nth-child(40) { background-position: -150px -80px; }
        .fence-block:nth-child(41) { background-position: -200px -80px; }
        .fence-block:nth-child(42) { background-position: -250px -80px; }
        .fence-block:nth-child(43) { background-position: -300px -80px; }
        .fence-block:nth-child(44) { background-position: -350px -80px; }
        .fence-block:nth-child(45) { background-position: -400px -80px; }
        
        .fence-block:nth-child(46) { background-position: 0 -100px; }
        .fence-block:nth-child(47) { background-position: -50px -100px; }
        .fence-block:nth-child(48) { background-position: -100px -100px; }
        .fence-block:nth-child(49) { background-position: -150px -100px; }
        .fence-block:nth-child(50) { background-position: -200px -100px; }
        .fence-block:nth-child(51) { background-position: -250px -100px; }
        .fence-block:nth-child(52) { background-position: -300px -100px; }
        .fence-block:nth-child(53) { background-position: -350px -100px; }
        .fence-block:nth-child(54) { background-position: -400px -100px; }
        
        .fence-block:nth-child(55) { background-position: 0 -120px; }
        .fence-block:nth-child(56) { background-position: -50px -120px; }
        .fence-block:nth-child(57) { background-position: -100px -120px; }
        .fence-block:nth-child(58) { background-position: -150px -120px; }
        .fence-block:nth-child(59) { background-position: -200px -120px; }
        .fence-block:nth-child(60) { background-position: -250px -120px; }
        .fence-block:nth-child(61) { background-position: -300px -120px; }
        .fence-block:nth-child(62) { background-position: -350px -120px; }
        .fence-block:nth-child(63) { background-position: -400px -120px; }
        
        .fence-block:nth-child(64) { background-position: 0 -140px; }
        .fence-block:nth-child(65) { background-position: -50px -140px; }
        .fence-block:nth-child(66) { background-position: -100px -140px; }
        .fence-block:nth-child(67) { background-position: -150px -140px; }
        .fence-block:nth-child(68) { background-position: -200px -140px; }
        .fence-block:nth-child(69) { background-position: -250px -140px; }
                 .fence-block:nth-child(70) { background-position: -300px -140px; }
         .fence-block:nth-child(71) { background-position: -350px -140px; }
         .fence-block:nth-child(72) { background-position: -400px -140px; }
         
         /* Стили для крышек (накрывочных плит) */
         .fence-peak {
             width: 50px; /* 0.5м = 50px */
             height: 5px; /* 0.05м = 5px */
             background-size: 150px 5px; /* 3x1 сетка текстур, каждая 50x5px */
             background-repeat: no-repeat;
             border-bottom: 1px solid rgba(255,255,255,0.3);
             display: block;
             position: absolute;
             top: -5px; /* Позиционируем вплотную к блоку */
             z-index: 101; /* Выше блоков столба */
             pointer-events: none; /* Не блокируем клики по основному элементу */
         }
         
         /* Стили для крышек с текстурами (3x1 сетка) */
                 .fence-peak:nth-child(1) { background-position: 0 0; }
        .fence-peak:nth-child(2) { background-position: -50px 0; }
        .fence-peak:nth-child(3) { background-position: -100px 0; }
        
        /* Линия земли */
        .ground-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 30px;
            background: linear-gradient(to bottom, rgba(74, 74, 74, 0.5) 0%, rgba(59, 47, 34, 0.5) 45%, rgba(43, 34, 15, 0.5) 100%);
            z-index: 10;
            transition: background 0.3s ease;
        }
        
        /* Линия земли с загруженным фото (больше прозрачности) */
        .ground-line.with-background {
            background: linear-gradient(to bottom, rgba(74, 74, 74, 0.8) 0%, rgba(59, 47, 34, 0.8) 45%, rgba(43, 34, 15, 0.8) 100%);
        }
        
        /* Убираем стрелки в input number полях */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        input[type="number"] {
            -moz-appearance: textfield;
        }
        
        /* Стили для светлой темы сайдбара */
        .floating-editor-sidebar {
            background: #ffffff !important;
            border-color: #e0e0e0 !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1) !important;
        }
        
        .floating-editor-sidebar input,
        .floating-editor-sidebar select {
            background: #f9f9f9 !important;
            border: 1px solid #ddd !important;
            color: #333 !important;
        }
        
        .floating-editor-sidebar label {
            color: #666 !important;
        }

        /* Линейка под забором */
        .fence-ruler {
            position: absolute;
            height: 30px;
            left: -50000px;
            width: 100000px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #cfcfcf;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: visible;
            z-index: 15;
            pointer-events: none;
        }
        .fence-ruler-segment {
            position: absolute;
            top: 0;
            height: 100%;
            border-right: 1px solid #bdbdbd;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-size: 12px;
            font-weight: 600;
        }
        .fence-ruler-total {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            border: 1px solid #cfcfcf;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 12px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Левая панель -->
        <div class="sidebar">
            <!-- Верхние кнопки управления -->
            <div class="top-controls">
                <button onclick="saveProject()">Сохранить</button>
                <button onclick="manualScreenshot()">Ручной скриншот</button>
                <button onclick="clearProject()">Очистить</button>
                <button onclick="openBackgroundUpload()">Загрузить фото</button>
                <input type="file" id="bgUploadInput" accept="image/*" style="display:none" />
        </div>
        
            <!-- Панель инструментов -->
            <div class="toolbar">
                <h3>Инструменты</h3>
                <div class="tools-grid">
                    <button class="tool-button" title="Добавить столб" onclick="addPole()">
                        <img src="filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/icons/toolbar-main/pole.png" alt="Столб" width="32" height="32">
                        </button>
                    <button class="tool-button" title="Добавить пролёт" onclick="addWall()">
                        <img src="filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/icons/toolbar-main/curtain.png" alt="Пролёт" width="32" height="20">
                        </button>
                    <button class="tool-button" title="Добавить калитку" onclick="addWicket()">
                        <img src="filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/icons/toolbar-main/wicket.png" alt="Калитка" width="32" height="32">
                        </button>
                    <button class="tool-button" title="Добавить ворота" onclick="addGate()">
                        <img src="filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/icons/toolbar-main/gate.png" alt="Ворота" width="32" height="32">
                        </button>
                    <button class="tool-button" title="Добавить пропуск" onclick="addSpace()">
                        <img src="filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/icons/toolbar-main/space.png" alt="Пропуск" width="32" height="22">
                        </button>
                    <button class="tool-button" title="Добавить отрезок" onclick="openEpisodeMenu()">
                        <img src="filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/icons/toolbar-main/episode.png" alt="Отрезок" width="32" height="20">
                        </button>
                    </div>
                </div>
                
            <!-- Секция добавления отрезка (вместо меню добавления пролёта) -->
            <div class="add-span-section" id="episodeAddSection" style="display: none;">
                <h3>Добавить отрезок</h3>
                <div class="form-group">
                    <label for="episodeLength">Длина отрезка (м)</label>
                    <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                        <button class="number-btn" onclick="incrementEpisodeLength(-0.5)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                        <input type="number" id="episodeLength" value="12" step="0.5" min="0.5" style="width: 75px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px; -webkit-appearance: none; -moz-appearance: textfield;">
                        <button class="number-btn" onclick="incrementEpisodeLength(0.5)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="poleDistance">Ширина пролёта (м)</label>
                    <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                        <button class="number-btn" onclick="incrementEpisodeSpanWidth(-0.5)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                        <input type="number" id="poleDistance" value="2.5" step="0.5" min="0" style="width: 75px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px; -webkit-appearance: none; -moz-appearance: textfield;">
                        <button class="number-btn" onclick="incrementEpisodeSpanWidth(0.5)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="episodePoleHeight">Высота столба (в блоках)</label>
                    <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                        <button class="number-btn" onclick="incrementEpisodePoleHeight(-1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                        <input type="number" id="episodePoleHeight" value="8" step="1" min="1" max="20" style="width: 75px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px; -webkit-appearance: none; -moz-appearance: textfield;">
                        <button class="number-btn" onclick="incrementEpisodePoleHeight(1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                    </div>
                </div>
                <button class="add-button" onclick="addEpisode()">Добавить отрезок</button>
                    </div>
                </div>
                
            
                
                <!-- Перемещаемый сайдбар для редактирования элементов -->
        <div class="floating-editor-sidebar" id="floatingEditorSidebar" style="display: none; position: fixed; right: 50px; top: 50%; transform: translateY(-50%); width: 280px; background: #ffffff; border: 2px solid #e0e0e0; border-radius: 8px; z-index: 1000; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); color: #333; cursor: move;">
            <div class="editor-header" style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #ddd;">
                <h3 id="editorTitle" style="margin: 0; color: #ff6600; font-size: 16px;">Редактирование элемента</h3>
                <button class="close-editor" onclick="closeFloatingEditor()" style="position: absolute; top: 15px; right: 15px; background: none; border: none; color: #333; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px;">×</button>
                        </div>
            
            <!-- Секция для столбов -->
            <div id="poleEditorSection" style="display: none;">
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Высота столба (блоки):</label>
                    <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                        <button class="number-btn" onclick="changePoleHeight(-1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                        <input type="text" id="poleHeightEditor" value="8" readonly style="width: 50px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px;">
                        <button class="number-btn" onclick="changePoleHeight(1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                        </div>
                        </div>
                <label for="applyToAllPoles" style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #666; font-size: 13px;">
                    <input type="checkbox" id="applyToAllPoles" onchange="toggleApplyToAllPoles()" style="width: 14px; height: 14px;">
                    <span>Применить для всех столбов</span>
                </label>
                
                <div class="form-group" style="margin-bottom: 15px; margin-top: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Цвет блоков:</label>
                    <div class="color-buttons" style="display: flex; gap: 10px;">
                        <button id="poleBlockColorOnyx" onclick="changeBlockColor('onyx')" style="width: 60px; height: 30px; background: #666; border: 2px solid #444; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Оникс</button>
                        <button id="poleBlockColorBlackMix" onclick="changeBlockColor('black_mix')" style="width: 60px; height: 30px; background: #333; border: 2px solid #111; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Черный микс</button>
                    </div>
                </div>
            </div>
            
            <!-- Секция для пролётов -->
            <div id="spanEditorSection" style="display: none;">
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Ширина пролета (м):</label>
                    <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                        <button class="number-btn" onclick="changeSpanWidth(-0.5)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                        <input type="number" id="spanWidthEditor" value="2.5" step="0.5" min="0" style="width: 50px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px; -webkit-appearance: none; -moz-appearance: textfield;">
                        <button class="number-btn" onclick="changeSpanWidth(0.5)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                </div>
                    <label for="applyWidthToAllSpans" style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #666; font-size: 13px; margin-top: 8px;">
                        <input type="checkbox" id="applyWidthToAllSpans" style="width: 14px; height: 14px;">
                        <span>Применить для всех пролётов</span>
                    </label>
            </div>
            
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Количество рядов блоков:</label>
                    <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                        <button class="number-btn" onclick="changeSpanRows(-1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                        <input type="number" id="spanRowsEditor" value="1" min="1" max="20" style="width: 50px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px; -webkit-appearance: none; -moz-appearance: textfield;">
                        <button class="number-btn" onclick="changeSpanRows(1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                        </div>
                    <label for="applyRowsToAllSpans" style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #666; font-size: 13px; margin-top: 8px;">
                        <input type="checkbox" id="applyRowsToAllSpans" style="width: 14px; height: 14px;">
                        <span>Применить для всех пролётов</span>
                    </label>
                        </div>
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Тип заполнения:</label>
                    <div class="color-buttons" style="display: flex; gap: 10px;">
                        <button id="spanColorGray" onclick="changeSpanColor('gray')" style="width: 60px; height: 30px; background: #555; border: 2px solid #333; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Серый</button>
                        <button id="spanColorMokka" onclick="changeSpanColor('mokka')" style="width: 60px; height: 30px; background: #8B4513; border: 2px solid #654321; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Mokka</button>
                        <button id="spanColorRanch" onclick="changeSpanColor('ranch')" style="width: 60px; height: 30px; background: #8B7355; border: 2px solid #6B5B47; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Ранчо</button>
                        </div>
                    </div>
                    
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Цвет блоков:</label>
                    <div class="color-buttons" style="display: flex; gap: 10px;">
                        <button id="blockColorOnyx" onclick="changeBlockColor('onyx')" style="width: 60px; height: 30px; background: #666; border: 2px solid #444; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Оникс</button>
                        <button id="blockColorBlackMix" onclick="changeBlockColor('black_mix')" style="width: 60px; height: 30px; background: #333; border: 2px solid #111; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Черный микс</button>
                        </div>
                    </div>

                </div>
            
            <!-- Секция для калиток -->
            <div id="wicketEditorSection" style="display: none;">
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Ширина калитки (м):</label>
                    <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                        <button class="number-btn" onclick="changeWicketWidth(-0.1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                        <input type="number" id="wicketWidthEditor" value="1.0" step="0.1" min="0.5" max="2.0" style="width: 50px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px; -webkit-appearance: none; -moz-appearance: textfield;">
                        <button class="number-btn" onclick="changeWicketWidth(0.1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                    </div>
                    <!-- Чекбокс "применить для всех калиток" убран -->
            </div>
            
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Тип заполнения:</label>
                    <div class="color-buttons" style="display: flex; gap: 10px;">
                        <button id="wicketColorGray" onclick="changeWicketColor('gray')" style="width: 60px; height: 30px; background: #555; border: 2px solid #333; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Серый</button>
                        <button id="wicketColorMokka" onclick="changeWicketColor('mokka')" style="width: 60px; height: 30px; background: #8B4513; border: 2px solid #654321; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Mokka</button>
                        <button id="wicketColorRanch" onclick="changeWicketColor('ranch')" style="width: 60px; height: 30px; background: #8B7355; border: 2px solid #6B5B47; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Ранчо</button>
                    </div>
                </div>
            </div>
            
            <!-- Секция для ворот -->
            <div id="gateEditorSection" style="display: none;">
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Ширина ворот (м):</label>
                    <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                        <button class="number-btn" onclick="changeGateWidth(-0.1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                        <input type="number" id="gateWidthEditor" value="4.0" step="0.1" min="2.0" max="6.0" style="width: 50px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px; -webkit-appearance: none; -moz-appearance: textfield;">
                        <button class="number-btn" onclick="changeGateWidth(0.1)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                    </div>
                    <!-- Чекбокс "применить для всех ворот" убран -->
                </div>
                
                <div class="form-group" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Тип заполнения:</label>
                    <div class="color-buttons" style="display: flex; gap: 10px;">
                        <button id="gateColorGray" onclick="changeGateColor('gray')" style="width: 60px; height: 30px; background: #555; border: 2px solid #333; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Серый</button>
                        <button id="gateColorMokka" onclick="changeGateColor('mokka')" style="width: 60px; height: 30px; background: #8B4513; border: 2px solid #654321; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Mokka</button>
                        <button id="gateColorRanch" onclick="changeGateColor('ranch')" style="width: 60px; height: 30px; background: #8B7355; border: 2px solid #6B5B47; border-radius: 4px; cursor: pointer; color: white; font-size: 12px;">Ранчо</button>
                    </div>
                </div>
            </div>
            

        </div>
            
        <!-- Центральная область -->
        <div class="main-canvas">
            <!-- Canvas для рисования -->
                <canvas id="canvas"></canvas>
                
                <!-- Линия земли будет создаваться динамически в контейнере забора -->
            
                    <!-- Переключатель день/ночь -->
        <div class="day-night-switch">
            <button class="switch-button" id="dayNightSwitch" title="Переключить день/ночь">☀️</button>
        </div>
        
        <!-- Индикатор масштаба -->
                <div class="zoom-indicator" id="zoomIndicator">
            Масштаб: 100%
                </div>
                </div>
        
        <!-- Нижняя панель -->
        <div class="bottom-bar">
            <div class="info-display">
                <div class="info-item">
                    <div class="info-label">Блоки</div>
                    <div class="info-value" id="blockCount">0</div>
            </div>
                <div class="info-item">
                    <div class="info-label">Крышки</div>
                    <div class="info-value" id="capCount">0</div>
        </div>
                <div class="info-item">
                    <div class="info-label">Столбы</div>
                    <div class="info-value" id="poleCount">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Пролеты</div>
                    <div class="info-value" id="panelCount">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Калитки</div>
                    <div class="info-value" id="wicketCount">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Ворота</div>
                    <div class="info-value" id="gateCount">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Общая длина</div>
                    <div class="info-value" id="totalLength">0.00 м</div>
                </div>
            </div>
            
            <div class="right-section">
                <button class="calculate-button" onclick="calculateProject()">РАСЧЁТ</button>
                <div class="copyright">ПлиточкаБай © 2024</div>
            </div>
        </div>
    </div>

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <script>
        // Основные переменные приложения
        let canvas, ctx;
        let is3D = false;
        let zoom = 1;
        let panX = 0, panY = 0;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        let canvasWidth = 3000; // Увеличиваем размер полотна вправо
        
        // Предзагруженные фоновые изображения
        let dayBackgroundImage = null;
        let nightBackgroundImage = null;
        let customBackgroundImage = null; // пользовательский фон
        
        let project = {
            elements: [],
            totalLength: 0,
            poleCount: 0,
            panelCount: 0,
            wicketCount: 0,
            gateCount: 0,
            spaceCount: 0,
            episodeCount: 0,
            totalCost: 0
        };
        
        // Переменные для редактирования столба
        let selectedPole = null;
        let selectedPoleElement = null;
        
        // Переменные для редактирования пролёта
        let selectedSpan = null;
        let selectedSpanElement = null;
        
        // Переменные для редактирования ворот и калиток
        let selectedGate = null;
        let selectedGateElement = null;
        let selectedWicket = null;
        let selectedWicketElement = null;
        // Переменные для редактирования проёма
        let selectedSpace = null;
        let selectedSpaceElement = null;
        
        // Глобальный цвет/тип заполнения для пролётов
        // По умолчанию используем "Ранчо" (полосы с прозрачными прорезями)
        let globalFillColor = 'ranch';
        
        // Глобальный цвет блоков (onyx по умолчанию)
        let globalBlockColor = 'onyx';
        // Глобальные закреплённые значения (пин)
        let pinnedPoleHeight = null; // number | null
        let pinnedSpanWidthM = null; // number meters
        let pinnedSpanRows = null; // number
        
        // Функции для получения настроек по умолчанию для новых элементов
        function getDefaultPoleHeight() {
            if (pinnedPoleHeight != null) return pinnedPoleHeight;
            const applyToAll = document.getElementById('applyToAllPoles');
            if (applyToAll && applyToAll.checked && selectedPole) {
                return selectedPole.height || 8;
            }
            return 8;
        }
        
        function getDefaultSpanWidth() {
            if (pinnedSpanWidthM != null) return pinnedSpanWidthM;
            const applyToAll = document.getElementById('applyWidthToAllSpans');
            if (applyToAll && applyToAll.checked && selectedSpan) {
                return selectedSpan.length / 100 || 2.5;
            }
            const poleDistanceEl = document.getElementById('poleDistance');
            return poleDistanceEl ? parseFloat(poleDistanceEl.value) || 2.5 : 2.5;
        }
        
        function getDefaultSpanRows() {
            if (pinnedSpanRows != null) return pinnedSpanRows;
            const applyToAll = document.getElementById('applyRowsToAllSpans');
            if (applyToAll && applyToAll.checked && selectedSpan) {
                return selectedSpan.rows || 1;
            }
            return 1;
        }
        
        // Функции для работы с полосками выделения
        function addSelectionHighlight(element) {
            // Удаляем существующую полоску, если есть
            removeSelectionHighlight(element);
            
            // Создаем новую полоску выделения
            const highlight = document.createElement('div');
            highlight.className = 'selection-highlight';
            highlight.style.cssText = `
                position: absolute;
                bottom: -5px;
                left: -7px;
                right: -7px;
                height: 4px;
                background: linear-gradient(to right, 
                    rgba(255, 165, 0, 0) 0%, 
                    rgba(255, 140, 0, 0.9) 15%, 
                    rgba(255, 215, 0, 1) 30%, 
                    rgba(255, 165, 0, 1) 50%, 
                    rgba(255, 140, 0, 1) 70%, 
                    rgba(255, 140, 0, 0.9) 85%, 
                    rgba(255, 165, 0, 0) 100%);
                border-radius: 2px;
                box-shadow: 0 0 8px rgba(255, 165, 0, 0.6), 0 0 16px rgba(255, 215, 0, 0.4);
                z-index: 200;
                pointer-events: none;
            `;
            
            element.appendChild(highlight);
            
            console.log('Добавлена подсветка для элемента:', element.id || element.className);
        }
        
        function removeSelectionHighlight(element) {
            const existing = element.querySelector('.selection-highlight');
            if (existing) {
                existing.remove();
            }
        }
        
        function removeAllSelectionHighlights() {
            document.querySelectorAll('.selection-highlight').forEach(highlight => {
                highlight.remove();
            });
        }
        
        // Функция для восстановления подсветки выбранного элемента
        function restoreSelectionHighlight(selectedInfo) {
            if (!selectedInfo) return;
            
            // Находим элемент по типу и ID
            let elementToHighlight = null;
            
            // Ищем элемент по data-element-id
            elementToHighlight = document.querySelector(`[data-element-id="${selectedInfo.id}"]`);
            
            if (elementToHighlight) {
                // Восстанавливаем класс selected
                elementToHighlight.classList.add('selected');
                
                // Восстанавливаем подсветку
                addSelectionHighlight(elementToHighlight);
                
                console.log('Восстановлена подсветка для элемента:', selectedInfo.type, selectedInfo.id);
            } else {
                console.log('Элемент для восстановления подсветки не найден:', selectedInfo.type, selectedInfo.id);
            }
        }
        
        // Инициализация приложения
        function init() {
            console.log('Инициализация приложения...');
            canvas = document.getElementById('canvas');
            console.log('Canvas найден:', canvas);
            
            if (!canvas) {
                console.error('Canvas не найден!');
                return;
            }
            
            ctx = canvas.getContext('2d');
            
            // Добавляем постоянные водяные знаки
            addPermanentWatermarks();
            setupCanvas();
            
            // Предзагружаем фоновые изображения
            preloadBackgroundImages();
            
            updateInfo();
            updateZoomIndicator(); // Инициализируем индикатор масштаба
            drawScene();
            console.log('Инициализация завершена');
        }
        
        // Предзагрузка фоновых изображений
        function preloadBackgroundImages() {
            // Загружаем дневное изображение
            dayBackgroundImage = new Image();
            dayBackgroundImage.onload = () => {
                console.log('Дневное фоновое изображение загружено');
                if (!isNightMode) {
                    drawScene(); // Перерисовываем сцену если сейчас день
                }
            };
            dayBackgroundImage.src = 'filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/environment/day_1k.jpg';
            
            // Загружаем ночное изображение
            nightBackgroundImage = new Image();
            nightBackgroundImage.onload = () => {
                console.log('Ночное фоновое изображение загружено');
                if (isNightMode) {
                    drawScene(); // Перерисовываем сцену если сейчас ночь
                }
            };
            nightBackgroundImage.src = 'filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/environment/night_1k.jpg';
        }
        
        // Настройка canvas
        function setupCanvas() {
            console.log('Настройка canvas...');
            console.log('Canvas offset размеры:', canvas.offsetWidth, 'x', canvas.offsetHeight);
            
            canvas.width = Math.max(canvas.offsetWidth, 400);
            canvas.height = Math.max(canvas.offsetHeight, 300);
            
            // Устанавливаем размер полотна равным размеру canvas для избежания дублирования
            canvasWidth = canvas.width;
            
            console.log('Canvas установленные размеры:', canvas.width, 'x', canvas.height);
            console.log('Размер полотна:', canvasWidth, 'x', canvas.height);
            
            // Обработчик события колесика мыши для зума
            canvas.addEventListener('wheel', (event) => {
                console.log('Событие wheel сработало!', event.deltaY);
                event.preventDefault();
                
                // Получаем координаты мыши относительно canvas
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                console.log('Координаты мыши:', mouseX, mouseY);
                console.log('Текущий зум до изменения:', zoom);
                
                // Определяем направление прокрутки
                // deltaY > 0 - прокрутка вниз (отдаление)
                // deltaY < 0 - прокрутка вверх (приближение)
                const zoomSpeed = 0.1;
                const delta = event.deltaY < 0 ? zoomSpeed : -zoomSpeed;
                
                console.log('Изменение зума:', delta);
                
                // Сохраняем старый зум
                const oldZoom = zoom;
                
                // Применяем новый зум
                zoom += delta;
                zoom = Math.max(0.1, Math.min(5.0, zoom)); // Ограничиваем зум от 10% до 500%
                
                console.log('Новый зум:', zoom);
                
                // Вычисляем изменение зума
                const zoomChange = zoom / oldZoom;
                
                // Корректируем панорамирование, чтобы зум происходил в точке курсора
                panX = mouseX - (mouseX - panX) * zoomChange;
                panY = mouseY - (mouseY - panY) * zoomChange;
                
                console.log('Новое панорамирование:', panX, panY);
                
                // Обновляем индикатор масштаба
                updateZoomIndicator();
                
                // Обновляем трансформацию контейнера забора
                const fenceContainer = document.getElementById('fenceContainer');
                if (fenceContainer) {
                    applyTransformToContainer(fenceContainer);
                }
                
                // Перерисовываем сцену
                drawScene();
                
                console.log('Зум применен, сцена перерисована');
            });
            
            // Обработчики мыши для перемещения полотна
            canvas.addEventListener('mousedown', (event) => {
                if (event.button === 0) { // Левая кнопка мыши
                    isDragging = true;
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                    canvas.style.cursor = 'grabbing';
                    console.log('Начало перетаскивания полотна');
                }
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const deltaX = event.clientX - lastMouseX;
                    const deltaY = event.clientY - lastMouseY;
                    
                    // Просто добавляем смещение к текущему панорамированию
                    panX += deltaX;
                    panY += deltaY;
                    
                    lastMouseX = event.clientX;
                    lastMouseY = event.clientY;
                    
                    // Обновляем трансформацию контейнера забора
                    const fenceContainer = document.getElementById('fenceContainer');
                    if (fenceContainer) {
                        applyTransformToContainer(fenceContainer);
                    }
                    
                    // Перерисовываем сцену
                    drawScene();
                    
                    console.log('Перемещение полотна:', panX, panY);
                }
            });
            
            canvas.addEventListener('mouseup', (event) => {
                if (event.button === 0) { // Левая кнопка мыши
                    isDragging = false;
                    canvas.style.cursor = 'default';
                    console.log('Конец перетаскивания полотна');
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'default';
                    console.log('Конец перетаскивания полотна (мышь покинула canvas)');
                }
            });
            
            // Также добавляем обработчик к контейнеру main-canvas для DOM-элементов
            const mainCanvasContainer = document.querySelector('.main-canvas');
            if (mainCanvasContainer) {
                // Обработчик колесика мыши для зума
                mainCanvasContainer.addEventListener('wheel', (event) => {
                    console.log('Событие wheel на main-canvas!', event.deltaY);
                    event.preventDefault();
                    
                    // Получаем координаты мыши относительно контейнера
                    const rect = mainCanvasContainer.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;
                    
                    console.log('Координаты мыши в контейнере:', mouseX, mouseY);
                    console.log('Текущий зум до изменения:', zoom);
                    
                    // Определяем направление прокрутки
                    const zoomSpeed = 0.1;
                    const delta = event.deltaY < 0 ? zoomSpeed : -zoomSpeed;
                    
                    console.log('Изменение зума:', delta);
                    
                    // Сохраняем старый зум
                    const oldZoom = zoom;
                    
                    // Применяем новый зум
                    zoom += delta;
                    zoom = Math.max(0.1, Math.min(5.0, zoom));
                    
                    console.log('Новый зум:', zoom);
                    
                    // Вычисляем изменение зума
                    const zoomChange = zoom / oldZoom;
                    
                    // Корректируем панорамирование
                    panX = mouseX - (mouseX - panX) * zoomChange;
                    panY = mouseY - (mouseY - panY) * zoomChange;
                    
                    console.log('Новое панорамирование:', panX, panY);
                    
                    // Обновляем индикатор масштаба
                    updateZoomIndicator();
                    
                    // Обновляем трансформацию контейнера забора
                    const fenceContainer = document.getElementById('fenceContainer');
                    if (fenceContainer) {
                        applyTransformToContainer(fenceContainer);
                    }
                    
                    // Перерисовываем сцену
                    drawScene();
                    
                    console.log('Зум применен, сцена перерисована');
                });
                
                // Обработчики мыши для перемещения полотна на main-canvas
                mainCanvasContainer.addEventListener('mousedown', (event) => {
                    if (event.button === 0) { // Левая кнопка мыши
                        isDragging = true;
                        lastMouseX = event.clientX;
                        lastMouseY = event.clientY;
                        mainCanvasContainer.style.cursor = 'grabbing';
                        console.log('Начало перетаскивания полотна (main-canvas)');
                    }
                });
                
                mainCanvasContainer.addEventListener('mousemove', (event) => {
                    if (isDragging) {
                        const deltaX = event.clientX - lastMouseX;
                        const deltaY = event.clientY - lastMouseY;
                        
                        // Просто добавляем смещение к текущему панорамированию
                        panX += deltaX;
                        panY += deltaY;
                        
                        lastMouseX = event.clientX;
                        lastMouseY = event.clientY;
                        
                        // Обновляем трансформацию контейнера забора
                        const fenceContainer = document.getElementById('fenceContainer');
                        if (fenceContainer) {
                            applyTransformToContainer(fenceContainer);
                        }
                        
                        // Перерисовываем сцену
                        drawScene();
                        
                        console.log('Перемещение полотна (main-canvas):', panX, panY);
                    }
                });
                
                mainCanvasContainer.addEventListener('mouseup', (event) => {
                    if (event.button === 0) { // Левая кнопка мыши
                        isDragging = false;
                        mainCanvasContainer.style.cursor = 'default';
                        console.log('Конец перетаскивания полотна (main-canvas)');
                    }
                });
                
                mainCanvasContainer.addEventListener('mouseleave', () => {
                    if (isDragging) {
                        isDragging = false;
                        mainCanvasContainer.style.cursor = 'default';
                        console.log('Конец перетаскивания полотна (main-canvas, мышь покинула)');
                    }
                });
            }
            
            window.addEventListener('resize', () => {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                drawScene();
            });
        }
        
        // Рисование сцены
        function drawScene() {
            console.log('Рисуем сцену...');
            console.log('Элементов для рендера:', project.elements.length);
            
            if (!ctx) {
                console.error('Canvas context не готов!');
                return;
            }
            
            // Очистка
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Фон
            drawBackground();
            
            // Сохраняем контекст и применяем трансформации зума
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);
            
            // Сетка отключена
            // drawGrid();
            
            // Элементы ограждения (DOM-элементы)
            renderFenceElements();
            
            // Восстанавливаем контекст
            ctx.restore();
            
            console.log('Сцена отрисована');
        }
        
        // Функции добавления элементов
        function addPole() {
            console.log('Добавляем столб...');
            const pole = {
                type: 'pole',
                id: Date.now(),
                selected: false,
                height: getDefaultPoleHeight(), // Используем настройку "применить для всех"
                textures: [], // Сохраняем текстуры для каждого блока
                peakTexture: Math.floor(Math.random() * 3) // Случайная текстура крышки (0-2)
            };
            project.elements.push(pole);
            project.poleCount++;
            console.log('Столб добавлен:', pole);
            console.log('Всего элементов:', project.elements.length);
            updateInfo();
            console.log('Вызываем renderFenceElements...');
            renderFenceElements();
            console.log('renderFenceElements завершен');
        }
        
        function addWall() {
            const poleDistanceEl = document.getElementById('poleDistance');
            const length = poleDistanceEl ? parseFloat(poleDistanceEl.value) || 2.5 : 2.5;
            
            // Добавляем пролёт
            const panel = {
                type: 'panel',
                length: getDefaultSpanWidth() * 100, // Используем настройку "применить для всех"
                realLength: getDefaultSpanWidth(),
                id: Date.now(),
                selected: false,
                height: 8, // Высота по умолчанию
                rows: getDefaultSpanRows(), // Используем настройку "применить для всех"
                textures: [], // Сохраняем текстуры для каждого блока
                peakTextures: [] // Сохраняем текстуры крышек для каждого блока пролёта
            };
            project.elements.push(panel);
            project.panelCount++;
            
            // Добавляем столб справа от пролёта
            const pole = {
                type: 'pole',
                id: Date.now() + 1,
                selected: false,
                height: getDefaultPoleHeight(), // Используем настройку "применить для всех"
                textures: [], // Сохраняем текстуры для каждого блока
                peakTexture: Math.floor(Math.random() * 3), // Случайная текстура крышки (0-2)
                isAutoGenerated: true,
                linkedTo: panel.id
            };
            project.elements.push(pole);
            project.poleCount++;
            
            updateInfo();
            renderFenceElements();
        }
        
        function addWicket() {
            console.log('Добавляем калитку...');
            const wicket = {
                type: 'wicket',
                id: Date.now(),
                selected: false,
                width: 100, // Ширина по умолчанию 1м = 100px
                fillColor: globalFillColor, // Используем глобальный цвет заполнения
                textures: [], // Сохраняем текстуры для каждого блока
                peakTextures: [] // Сохраняем текстуры крышек для каждого блока
            };
            project.elements.push(wicket);
            project.wicketCount++;
            console.log('Калитка добавлена:', wicket);
            
            // Добавляем столб справа от калитки
            const pole = {
                type: 'pole',
                id: Date.now() + 1,
                selected: false,
                height: getDefaultPoleHeight(), // Используем настройку "применить для всех"
                textures: [], // Сохраняем текстуры для каждого блока
                peakTexture: Math.floor(Math.random() * 3), // Случайная текстура крышки (0-2)
                isAutoGenerated: true,
                linkedTo: wicket.id
            };
            project.elements.push(pole);
            project.poleCount++;
            console.log('Столб справа от калитки добавлен:', pole);
            
            console.log('Всего элементов:', project.elements.length);
            updateInfo();
            renderFenceElements();
        }
        
        function addGate() {
            console.log('Добавляем ворота...');
            const gate = {
                type: 'gate',
                id: Date.now(),
                selected: false,
                width: 400, // Ширина по умолчанию 4м = 400px
                fillColor: globalFillColor, // Используем глобальный цвет заполнения
                textures: [], // Сохраняем текстуры для каждого блока
                peakTextures: [] // Сохраняем текстуры крышек для каждого блока
            };
            project.elements.push(gate);
            project.gateCount++;
            console.log('Ворота добавлены:', gate);
            
            // Добавляем столб справа от ворот
            const pole = {
                type: 'pole',
                id: Date.now() + 1,
                selected: false,
                height: getDefaultPoleHeight(), // Используем настройку "применить для всех"
                textures: [], // Сохраняем текстуры для каждого блока
                peakTexture: Math.floor(Math.random() * 3), // Случайная текстура крышки (0-2)
                isAutoGenerated: true,
                linkedTo: gate.id
            };
            project.elements.push(pole);
            project.poleCount++;
            console.log('Столб справа от ворот добавлен:', pole);
            
            console.log('Всего элементов:', project.elements.length);
            updateInfo();
            renderFenceElements();
        }
        
        function addSpace() {
            const space = {
                type: 'space',
                id: Date.now(),
                selected: false,
                width: 100 // 1м по умолчанию
            };
            project.elements.push(space);
            project.spaceCount++;
            updateInfo();
            renderFenceElements();
        }
        
        function addEpisode() {
            // Читаем параметры отрезка
            const lenEl = document.getElementById('episodeLength');
            const spanWEl = document.getElementById('poleDistance');
            const poleHEl = document.getElementById('episodePoleHeight');

            let totalLengthM = lenEl ? parseFloat(lenEl.value) : 10;
            let spanWidthM = spanWEl ? parseFloat(spanWEl.value) : 2.5;
            let poleHeightBlocks = poleHEl ? parseInt(poleHEl.value) : 8;

            if (!isFinite(totalLengthM) || totalLengthM <= 0.5) return; // минимум 0.5м на финальный столб
            if (!isFinite(spanWidthM) || spanWidthM < 0.5) spanWidthM = 0.5;
            if (!isFinite(poleHeightBlocks) || poleHeightBlocks < 1) poleHeightBlocks = 1;

            let remaining = totalLengthM;
            const rowsForSpans = getDefaultSpanRows();

            // Будем добавлять: пролёт -> столб, пока не останется 0.5м под финальный столб
            while (remaining > 0.5 + 1e-6) {
                const maxSpanAllowed = Math.max(0, remaining - 0.5); // резерв под правый столб
                if (maxSpanAllowed < 0.5 - 1e-6) break; // нельзя разместить даже минимальный пролёт

                const thisSpanWidth = Math.max(0.5, Math.min(spanWidthM, maxSpanAllowed));

                // Добавляем пролёт
                const panelId = Date.now() + Math.floor(Math.random() * 1000);
                const panel = {
                    type: 'panel',
                    length: thisSpanWidth * 100,
                    realLength: thisSpanWidth,
                    id: panelId,
                    selected: false,
                    height: poleHeightBlocks, // не критично; реальная высота берётся от правого столба
                    rows: rowsForSpans,
                    textures: [],
                    peakTextures: []
                };
                project.elements.push(panel);
                project.panelCount++;

                // Добавляем столб справа от пролёта
                const pole = {
                    type: 'pole',
                    id: panelId + 1,
                    selected: false,
                    height: poleHeightBlocks,
                    textures: [],
                    peakTexture: Math.floor(Math.random() * 3),
                    isAutoGenerated: true,
                    linkedTo: panelId
                };
                project.elements.push(pole);
                project.poleCount++;

                remaining -= (thisSpanWidth + 0.5);
            }

            updateInfo();
            renderFenceElements();
        }
        
        // Рисование фона
        function drawBackground() {
            // Пользовательский фон имеет приоритет над режимами
            if (customBackgroundImage) {
                ctx.drawImage(customBackgroundImage, 0, 0, canvas.width, canvas.height);
                return;
            }
            if (isNightMode) {
                if (nightBackgroundImage) ctx.drawImage(nightBackgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                if (dayBackgroundImage) ctx.drawImage(dayBackgroundImage, 0, 0, canvas.width, canvas.height);
            }
        }
        
        // Рисование сетки
        function drawGrid() {
            if (isNightMode) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            } else {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            }
            ctx.lineWidth = 1;
            
            const gridSize = 20;
            
            // Рисуем вертикальные линии сетки на всю ширину полотна
            for (let x = 0; x < canvasWidth; x += gridSize) {
                // Проверяем, находится ли линия в видимой области
                const screenX = (x - panX) * zoom;
                if (screenX >= -gridSize && screenX <= canvas.width + gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvas.height);
                    ctx.stroke();
                }
            }
            
            // Рисуем горизонтальные линии сетки
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // Создание и отображение элементов ограждения как DOM-элементов
        function renderFenceElements() {
            console.log('Начинаем renderFenceElements, всего элементов:', project.elements.length);
            console.log('Элементы проекта:', project.elements);
            
            // Сохраняем информацию о выбранном элементе перед очисткой
            let selectedElementInfo = null;
            if (selectedPoleElement) {
                selectedElementInfo = { type: 'pole', id: selectedPole.id };
            } else if (selectedSpanElement) {
                selectedElementInfo = { type: 'span', id: selectedSpan.id };
            } else if (selectedGateElement) {
                selectedElementInfo = { type: 'gate', id: selectedGate.id };
            } else if (selectedWicketElement) {
                selectedElementInfo = { type: 'wicket', id: selectedWicket.id };
            }
            
            // Очищаем существующие элементы
            const existingElements = document.querySelectorAll('.fence-post, .fence-span, .fence-gate, .fence-wicket');
            console.log('Удаляем существующие элементы:', existingElements.length);
            existingElements.forEach(el => el.remove());
            
            // Удаляем существующие контейнеры
            const existingContainer = document.getElementById('fenceContainer');
            if (existingContainer) existingContainer.remove();
            const existingViewport = document.getElementById('fenceViewport');
            if (existingViewport) existingViewport.remove();
            
            // Создаем внешний viewport для 3D вращения
            const fenceViewport = document.createElement('div');
            fenceViewport.id = 'fenceViewport';
            fenceViewport.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                transform-style: preserve-3d;
                z-index: 100;
            `;

            // Внутренний контейнер для пана/зума (как раньше)
            const fenceContainer = document.createElement('div');
            fenceContainer.id = 'fenceContainer';
            fenceContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                transform-origin: 0 0;
            `;
            
            let currentX = 100; // 100px от левого края (старт линейки)
            const startX = currentX;
            const groundY = canvas.height / 2; // Позиция в середине экрана (на уровне линии земли)
            const mainCanvas = document.querySelector('.main-canvas');
            console.log('Основной canvas найден:', !!mainCanvas);
            
            // Создаем линию земли в контейнере забора
            const groundLine = document.createElement('div');
            groundLine.className = 'ground-line';
            groundLine.id = 'groundLine'; // Добавляем ID для управления
            groundLine.style.cssText = `
                position: absolute;
                bottom: 50%; /* В середине экрана */
                left: -50000px; /* Уводим далеко влево */
                width: 100000px; /* Практически бесконечная ширина */
                height: 30px;
                background: linear-gradient(to bottom, rgba(74, 74, 74, 0.5) 0%, rgba(59, 47, 34, 0.5) 45%, rgba(43, 34, 15, 0.5) 100%);
                z-index: 10;
                transition: background 0.3s ease;
            `;
            fenceContainer.appendChild(groundLine);

            // Создаём линейку под забором
            const ruler = document.createElement('div');
            ruler.className = 'fence-ruler';
            ruler.style.bottom = `calc(50% - 46px)`; // немного ниже линии земли
            fenceContainer.appendChild(ruler);
            
            let xPositions = [];
            project.elements.forEach((element, index) => {
                console.log(`Создаем элемент ${index}:`, element);
                const x = currentX;
                const y = groundY;
                xPositions.push(x);
                
                let domElement = null;
                
                console.log(`Обрабатываем элемент типа: ${element.type}, позиция: x=${x}, y=${y}`);
                
                switch (element.type) {
                    case 'pole':
                        domElement = createPoleElement(x, y, 8, element);
                        currentX += 50; // Столб 0.5м = 50px
                        break;
                    case 'panel':
                        const panelLength = (typeof element.length === 'number') ? element.length : 100;
                        domElement = createPanelElement(x, y, panelLength, element);
                        currentX += panelLength;
                        break;
                    case 'gate':
                        domElement = createGateElement(x, y, element);
                        currentX += (element && element.width ? element.width : 400); // Используем ширину из элемента или по умолчанию
                        break;
                    case 'wicket':
                        domElement = createWicketElement(x, y, element);
                        currentX += (element && element.width ? element.width : 100); // Используем ширину из элемента или по умолчанию
                        break;
                    case 'space':
                        domElement = createSpaceElement(x, y, element);
                        currentX += (element && element.width ? element.width : 100);
                        break;
                    case 'episode':
                        const episodeLength = (element.length || 2.5) * 100;
                        domElement = createEpisodeElement(x, y, episodeLength);
                        currentX += episodeLength;
                        break;
                }
                
                if (domElement) {
                    // Добавляем элемент в контейнер забора (без индивидуальной трансформации)
                    fenceContainer.appendChild(domElement);
                }
            });

            // Заполняем сегменты линейки по xPositions
            const rulerEl = fenceContainer.querySelector('.fence-ruler');
            if (rulerEl) {
                rulerEl.innerHTML = '';
                const totalWidthPx = currentX - startX;
                rulerEl.style.left = `${startX}px`;
                rulerEl.style.width = `${totalWidthPx}px`;
                let cursor = startX; // начало линейки
                let totalM = 0;
                for (let i = 0; i < project.elements.length; i++) {
                    const el = project.elements[i];
                    let lengthPx = 0;
                    if (el.type === 'pole') {
                        lengthPx = 50; // 0.5м
                    } else if (el.type === 'panel') {
                        lengthPx = el.length || 0;
                    } else if (el.type === 'gate') {
                        lengthPx = el.width || 0;
                    } else if (el.type === 'wicket') {
                        lengthPx = el.width || 0;
                    } else if (el.type === 'space') {
                        lengthPx = el.width || 0;
                    } else if (el.type === 'episode') {
                        lengthPx = (el.length || 0) * 100;
                    }
                    const seg = document.createElement('div');
                    seg.className = 'fence-ruler-segment';
                    seg.style.left = `${cursor - startX}px`;
                    seg.style.width = `${lengthPx}px`;
                    seg.textContent = lengthPx > 0 ? `${(lengthPx/100).toFixed(2)} м` : '';
                    rulerEl.appendChild(seg);
                    cursor += lengthPx;
                    totalM += lengthPx/100;
                }
                const total = document.createElement('div');
                total.className = 'fence-ruler-total';
                total.textContent = `${totalM.toFixed(2)} м`;
                rulerEl.appendChild(total);
            }
            
            // Добавляем контейнер забора в main-canvas
            if (mainCanvas) {
                fenceViewport.appendChild(fenceContainer);
                mainCanvas.appendChild(fenceViewport);
                
                // Применяем трансформацию ко всему контейнеру
                applyTransformToContainer(fenceContainer);
                applyRotationToViewport(fenceViewport);
                console.log('Контейнер забора добавлен и трансформация применена');
            } else {
                console.error('main-canvas не найден!');
            }
            
            // Восстанавливаем подсветку выбранного элемента, если он был выбран
            if (selectedElementInfo) {
                restoreSelectionHighlight(selectedElementInfo);
            }
            
            // Обновляем сводные показатели (длина, количества, блоки/крышки)
            updateInfo();

            console.log('renderFenceElements завершен успешно');
        }
        
        // Применение трансформации зума и панорамирования к контейнеру забора
        function applyTransformToContainer(container) {
            const transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            container.style.transform = transform;
            container.style.transformOrigin = '0 0';
        }

        // --- 3D ВРАЩЕНИЕ ---
        let rotationX = 0; // градусы
        let rotationY = 0;
        let rotationZ = 0;
        let isRotating = false;
        let lastRX = 0, lastRY = 0;
        let startMouseX = 0, startMouseY = 0;

        function clamp(val, min, max) { return Math.min(max, Math.max(min, val)); }

        function applyRotationToViewport(viewport) {
            if (!viewport) return;
            viewport.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;
            viewport.style.transformStyle = 'preserve-3d';
        }

        function setupRotationControls() {
            const container = document.querySelector('.main-canvas');
            if (!container) return;

            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) { // ПКМ
                    isRotating = true;
                    startMouseX = e.clientX;
                    startMouseY = e.clientY;
                    lastRX = rotationX;
                    lastRY = rotationY;
                    container.style.cursor = 'move';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isRotating) return;
                const dx = e.clientX - startMouseX;
                const dy = e.clientY - startMouseY;
                // чувствительность
                const sens = 0.2;
                rotationY = clamp(lastRY + dx * sens, -80, 80);
                rotationX = clamp(lastRX - dy * sens, -60, 60);
                const viewport = document.getElementById('fenceViewport');
                applyRotationToViewport(viewport);
            });

            document.addEventListener('mouseup', () => {
                if (isRotating) {
                    isRotating = false;
                    container.style.cursor = 'default';
                }
            });
        }
        
        // Создание столба как DOM-элемент
        function createPoleElement(x, y, height = 8, element = null) {
            console.log('Создаем DOM-элемент столба:', {x, y, height, element});
            const pole = document.createElement('div');
            pole.className = 'fence-post';
            pole.id = `post${project.poleCount + 1}`;
            
            // Используем высоту из элемента, если она есть
            const actualHeight = element && element.height ? element.height : height;
            console.log('Фактическая высота столба:', actualHeight);
            
            const postWidth = 50;
            const postHeight = actualHeight * 20; // 20px на блок
            
            pole.style.cssText = `
                position: absolute;
                left: ${x}px;
                bottom: ${canvas.height - y + 30}px; /* Позиционируем от низа, выше линии земли */
                width: ${postWidth}px;
                height: ${postHeight}px;
                overflow: visible; /* Изменяем чтобы крышка была видна */
                z-index: 100;
                cursor: pointer;
            `;
            
            // Добавляем атрибут для идентификации элемента
            pole.setAttribute('data-element-id', element.id);
            
            // Создаем блоки для столба с разными текстурами
            let lastTexture = -1; // Отслеживаем последнюю использованную текстуру
            
            // Если у элемента уже есть сохранённые текстуры, используем их
            if (element && element.textures && element.textures.length > 0) {
                for (let i = 0; i < actualHeight; i++) {
                    const block = document.createElement('div');
                    block.className = 'fence-block';
                    block.style.cssText = `
                        width: 50px;
                        height: 20px;
                        background-size: 150px 60px;
                        background-repeat: no-repeat;
                        border-bottom: 1px solid rgba(255,255,255,0.3);
                        display: block;
                        position: absolute;
                        bottom: ${i * 20}px;
                        left: 0;
                    `;
                    
                    // Используем сохранённую текстуру
                    const savedTexture = element.textures[i];
                    const randomRow = Math.floor(savedTexture / 3);
                    const randomCol = savedTexture % 3;
                    
                    const xPos = -(randomCol * 50);
                    const yPos = -(randomRow * 20);
                    
                    block.style.backgroundImage = `url("${getBlockTexturePath()}")`;
                    block.style.backgroundPosition = `${xPos}px ${yPos}px`;
                    
                    pole.appendChild(block);
                }
            } else {
                // Создаём новые текстуры и сохраняем их
                if (element) element.textures = [];
                console.log('Генерируем новые текстуры для столба высотой:', actualHeight);
                
                for (let i = 0; i < actualHeight; i++) {
                    const block = document.createElement('div');
                    block.className = 'fence-block';
                    block.style.cssText = `
                        width: 50px;
                        height: 20px;
                        background-size: 150px 60px;
                        background-repeat: no-repeat;
                        border-bottom: 1px solid rgba(255,255,255,0.3);
                        display: block;
                        position: absolute;
                        bottom: ${i * 20}px;
                        left: 0;
                    `;
                    
                    // Выбираем текстуру, отличную от предыдущей
                    let randomRow, randomCol;
                    do {
                        randomRow = Math.floor(Math.random() * 3);
                        randomCol = Math.floor(Math.random() * 3);
                    } while (randomRow * 3 + randomCol === lastTexture);
                    
                    lastTexture = randomRow * 3 + randomCol; // Сохраняем текущую текстуру
                    console.log(`Блок ${i + 1}: текстура ${lastTexture} (ряд ${randomRow}, колонка ${randomCol})`);
                    
                    // Сохраняем текстуру в элементе
                    if (element) element.textures.push(lastTexture);
                    
                    // Используем реальное изображение width.jpg, разделенное на 3x3 сетка
                    // Каждая текстура имеет размер 50x20px
                    const xPos = -(randomCol * 50);
                    const yPos = -(randomRow * 20);
                    
                    block.style.backgroundImage = `url("${getBlockTexturePath()}")`;
                    block.style.backgroundPosition = `${xPos}px ${yPos}px`;
                    
                    pole.appendChild(block);
                }
                console.log('Сгенерированные текстуры:', element ? element.textures : 'нет элемента');
            }
            
            // Добавляем крышку над верхним блоком
            if (element && element.peakTexture !== undefined) {
                const peak = document.createElement('div');
                peak.className = 'fence-peak';
                peak.style.cssText = `
                    width: 50px;
                    height: 5px; /* 0.05м = 5px */
                    background-size: 150px 5px; /* 3x1 сетка, каждая текстура 50x5px */
                    background-repeat: no-repeat;
                    border-bottom: 1px solid rgba(255,255,255,0.3);
                    display: block;
                    position: absolute;
                    bottom: ${(actualHeight - 1) * 20 + 20}px; /* Позиционируем над верхним блоком */
                    left: 0;
                    z-index: 101;
                `;
                
                // Используем сохранённую текстуру крышки
                const peakTexture = element.peakTexture;
                const xPos = -(peakTexture * 50);
                
                peak.style.backgroundImage = `url("${getPeakTexturePath()}")`;
                peak.style.backgroundPosition = `${xPos}px 0px`;
                
                pole.appendChild(peak);
                console.log('Крышка добавлена над столбом с текстурой:', peakTexture);
            } else {
                console.log('Крышка не добавлена: element.peakTexture =', element ? element.peakTexture : 'undefined');
            }
            
            // Добавляем обработчик клика
            pole.addEventListener('click', function(event) {
                event.stopPropagation(); // Предотвращаем всплытие события
                
                // Убираем выделение со всех элементов
                document.querySelectorAll('.fence-post, .fence-span, .fence-gate, .fence-wicket').forEach(p => p.classList.remove('selected'));
                removeAllSelectionHighlights();
                
                // Сбрасываем все переменные выбора
                selectedSpan = null;
                selectedSpanElement = null;
                selectedGate = null;
                selectedGateElement = null;
                selectedWicket = null;
                selectedWicketElement = null;
                
                // Устанавливаем выбранный столб
                selectedPole = element;
                selectedPoleElement = this;
                
                // Выбираем текущий столб
                this.classList.add('selected');
                addSelectionHighlight(this);
                console.log('Выбран столб:', this.id);
                
                // Открываем редактор столба
                if (element) {
                    openFloatingEditor('pole', this, element);
                }
            });
            
            return pole;
        }
        
        // Создание панели как DOM-элемент
        // Вспомогательные функции для работы с текстурами пролёта
        function isTextureMatrix(value) {
            return Array.isArray(value) && value.length > 0 && Array.isArray(value[0]);
        }

        function generateRandomBlockTexture(excludeTexture) {
            let texture;
            do {
                texture = Math.floor(Math.random() * 9); // 3x3 = 9 вариантов
            } while (texture === excludeTexture);
            return texture;
        }
        
        // Функция для получения пути к текстуре блоков в зависимости от цвета
        function getBlockTexturePath(color = globalBlockColor) {
            if (color === 'black_mix') {
                return 'filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/systems/joniec-roma_horizon/blocks/rh/onyx/widthCHM.jpg';
            } else {
                return 'filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/systems/joniec-roma_horizon/blocks/rh/onyx/width.jpg';
            }
        }
        
        // Функция для получения пути к текстуре крышек в зависимости от цвета
        function getPeakTexturePath(color = globalBlockColor) {
            if (color === 'black_mix') {
                return 'filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/systems/joniec-roma_horizon/peaks/flat/onyx/widthCHM.jpg';
            } else {
                return 'filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/img/systems/joniec-roma_horizon/peaks/flat/onyx/width.jpg';
            }
        }

        function ensurePanelTextures(panel, rowsCount, blockCount) {
            if (!panel.textures) {
                panel.textures = [];
            }
            // Преобразование из плоского массива в матрицу, если необходимо
            if (!isTextureMatrix(panel.textures)) {
                const flat = Array.isArray(panel.textures) ? panel.textures.slice() : [];
                const prevRows = panel.rows || rowsCount || 1;
                // Пытаемся оценить прежнее число блоков в ряду
                const prevBlocksPerRow = prevRows > 0 ? Math.floor(flat.length / prevRows) : 0;
                const matrix = [];
                for (let r = 0; r < rowsCount; r++) {
                    matrix[r] = [];
                    for (let c = 0; c < Math.min(prevBlocksPerRow, blockCount); c++) {
                        const idx = r * prevBlocksPerRow + c;
                        if (idx < flat.length) {
                            matrix[r][c] = flat[idx];
                        }
                    }
                }
                panel.textures = matrix;
            }

            // Гарантируем корректные размеры матрицы: rowsCount x blockCount
            for (let r = 0; r < rowsCount; r++) {
                if (!panel.textures[r]) panel.textures[r] = [];
                let lastTexture = panel.textures[r].length > 0 ? panel.textures[r][panel.textures[r].length - 1] : -1;
                while (panel.textures[r].length < blockCount) {
                    panel.textures[r].push(generateRandomBlockTexture(lastTexture));
                    lastTexture = panel.textures[r][panel.textures[r].length - 1];
                }
                if (panel.textures[r].length > blockCount) {
                    panel.textures[r] = panel.textures[r].slice(0, blockCount);
                }
            }
            if (panel.textures.length > rowsCount) {
                panel.textures = panel.textures.slice(0, rowsCount);
            }
        }

        function ensurePanelPeakTextures(panel, blockCount) {
            if (!panel.peakTextures) panel.peakTextures = [];
            // Дополняем до нужной длины, сохраняя уже существующие значения
            while (panel.peakTextures.length < blockCount) {
                panel.peakTextures.push(Math.floor(Math.random() * 3)); // 3 текстуры крышек по ширине
            }
            if (panel.peakTextures.length > blockCount) {
                panel.peakTextures = panel.peakTextures.slice(0, blockCount);
            }
        }

        // Создание панели как DOM-элемент
        function createPanelElement(x, y, length, element = null) {
            const panel = document.createElement('div');
            panel.className = 'fence-span';
            panel.id = `panel${project.panelCount + 1}`;
            
            // Находим правый столб от пролёта для определения высоты заполнения
            const spanIndex = project.elements.findIndex(el => el.id === element.id);
            let rightPoleHeight = 8; // Высота по умолчанию
            
            if (spanIndex < project.elements.length - 1) {
                const rightPole = project.elements[spanIndex + 1];
                if (rightPole && rightPole.type === 'pole') {
                    rightPoleHeight = rightPole.height || 8;
                }
            }
            
            const panelHeight = rightPoleHeight * 20; // Высота заполнения равна высоте правого столба
            
            panel.style.cssText = `
                position: absolute;
                left: ${x}px;
                bottom: ${canvas.height - y + 30}px; /* Позиционируем от низа, выше линии земли */
                width: ${length}px;
                height: ${panelHeight}px; // Динамическая высота на основе количества рядов
                cursor: pointer;
                z-index: 50;
                overflow: visible; /* Позволяем крышкам быть видимыми */
            `;
            
            // Добавляем атрибут для идентификации элемента
            panel.setAttribute('data-element-id', element.id);
            
            // Применяем тип заполнения: ranch (по умолчанию) или mokka/gray
            if (globalFillColor === 'mokka') {
                panel.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/mokka1.jpg")';
                panel.style.backgroundSize = 'cover';
                panel.style.backgroundPosition = 'center';
                panel.style.backgroundRepeat = 'no-repeat';
            } else if (globalFillColor === 'ranch') {
                panel.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/ranCHo.png")';
                panel.style.backgroundSize = '100% 100%'; /* Растягиваем по всей ширине и высоте пролета */
                panel.style.backgroundRepeat = 'no-repeat';
                panel.style.backgroundPosition = 'center';
                panel.style.backgroundColor = 'transparent';
                panel.style.mixBlendMode = 'multiply'; /* Белые участки становятся прозрачными, темные остаются */
                panel.style.isolation = 'isolate'; /* Изолируем эффект смешивания */
            } else {
                panel.style.background = '#555';
            }
            
            // Создаем контейнер для всех рядов блоков
            const blocksContainer = document.createElement('div');
            blocksContainer.style.cssText = `
                position: absolute;
                bottom: 0px; /* На уровне нижних блоков столба */
                left: 0;
                width: 100%;
                height: ${(element && element.rows ? element.rows : 1) * 20 + 5}px; /* Высота блоков + крышки (5px) сверху */
                z-index: 102; /* Выше основной панели */
                pointer-events: none; /* Не блокируем клики по основному элементу */
            `;
            
            // Вычисляем количество блоков в ряду и количество рядов
            const blockCount = Math.floor(length / 50); // 50px на блок
            const rowsCount = element && element.rows ? element.rows : 1; // Количество рядов

            // Гарантируем корректные структуры текстур
            ensurePanelTextures(element, rowsCount, blockCount);
            ensurePanelPeakTextures(element, blockCount);

            // Создаем ряды блоков из матрицы текстур
            for (let rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
                const row = document.createElement('div');
                row.style.cssText = `
                    position: absolute;
                    bottom: ${rowIndex * 20}px;
                    left: 0;
                    width: 100%;
                    height: 20px;
                    display: flex;
                `;

                for (let i = 0; i < blockCount; i++) {
                    const block = document.createElement('div');
                    block.className = 'fence-block';
                    block.style.cssText = `
                        width: 50px;
                        height: 20px;
                        background-size: 150px 60px;
                        background-repeat: no-repeat;
                        ${rowIndex === rowsCount - 1 ? 'border-bottom: none;' : 'border-bottom: 1px solid rgba(255,255,255,0.3);'}
                        display: block;
                        flex-shrink: 0;
                    `;

                    const savedTexture = element.textures[rowIndex][i];
                    const texRow = Math.floor(savedTexture / 3);
                    const texCol = savedTexture % 3;
                    const xPos = -(texCol * 50);
                    const yPos = -(texRow * 20);
                    block.style.backgroundImage = `url("${getBlockTexturePath()}")`;
                    block.style.backgroundPosition = `${xPos}px ${yPos}px`;

                    row.appendChild(block);
                }

                blocksContainer.appendChild(row);
            }

            // Крышки над верхним рядом
            for (let i = 0; i < blockCount; i++) {
                const peak = document.createElement('div');
                peak.className = 'fence-peak';
                peak.style.cssText = `
                    width: 50px;
                    height: 5px;
                    background-size: 150px 5px;
                    background-repeat: no-repeat;
                    border-bottom: none;
                    display: block;
                    position: absolute;
                    bottom: ${rowsCount * 20}px;
                    top: auto;
                    left: ${i * 50}px;
                    z-index: 105;
                `;

                const peakTexture = element.peakTextures[i] || 0;
                const xPos = -(peakTexture * 50);
                peak.style.backgroundImage = `url("${getPeakTexturePath()}")`;
                peak.style.backgroundPosition = `${xPos}px 0px`;
                blocksContainer.appendChild(peak);
            }
            
            panel.appendChild(blocksContainer);
            
            // Добавляем обработчик клика
            panel.addEventListener('click', function(event) {
                event.stopPropagation(); // Предотвращаем всплытие события
                
                // Убираем выделение со всех элементов
                document.querySelectorAll('.fence-post, .fence-span, .fence-gate, .fence-wicket').forEach(p => p.classList.remove('selected'));
                removeAllSelectionHighlights();
                
                // Сбрасываем все переменные выбора
                selectedPole = null;
                selectedPoleElement = null;
                selectedGate = null;
                selectedGateElement = null;
                selectedWicket = null;
                selectedWicketElement = null;
                
                // Устанавливаем выбранную панель
                selectedSpan = element;
                selectedSpanElement = this;
                
                // Выделяем текущую панель
                this.classList.add('selected');
                
                // Для пролётов добавляем подсветку с особым позиционированием
                const highlight = document.createElement('div');
                highlight.className = 'selection-highlight';
                highlight.style.cssText = `
                    position: absolute;
                    bottom: -5px; /* Под нижним блоком, как у столбов */
                    left: -7px;
                    right: -7px;
                    height: 4px;
                    background: linear-gradient(to right, 
                        rgba(255, 165, 0, 0) 0%, 
                        rgba(255, 140, 0, 0.9) 15%, 
                        rgba(255, 215, 0, 1) 30%, 
                        rgba(255, 165, 0, 1) 50%, 
                        rgba(255, 140, 0, 1) 70%, 
                        rgba(255, 140, 0, 0.9) 85%, 
                        rgba(255, 165, 0, 0) 100%);
                    border-radius: 2px;
                    box-shadow: 0 0 8px rgba(255, 165, 0, 0.6), 0 0 16px rgba(255, 215, 0, 0.4);
                    z-index: 200;
                    pointer-events: none;
                `;
                this.appendChild(highlight);
                
                // Открываем редактор пролёта
                if (element) {
                    openFloatingEditor('span', this, element);
                }
                
                console.log('Выбрана панель:', this.id);
            });
            
            return panel;
        }
        
        // Создание ворот как DOM-элемент
        function createGateElement(x, y, element = null) {
            console.log('Создаем DOM-элемент ворот:', {x, y, element});
            const gate = document.createElement('div');
            gate.className = 'fence-gate';
            gate.id = `gate${project.gateCount + 1}`;
            
            const gateHeight = element && element.height ? element.height * 20 : 160; // Используем высоту из элемента или по умолчанию
            const gateWidth = element && element.width ? element.width : 400; // Используем ширину из элемента или по умолчанию
            
            gate.style.cssText = `
                position: absolute;
                left: ${x}px;
                bottom: ${canvas.height - y + 30}px; /* Позиционируем от низа, выше линии земли */
                width: ${gateWidth}px;
                height: ${gateHeight}px; // Динамическая высота на основе element.height
                cursor: pointer;
                z-index: 50;
            `;
            
            // Добавляем атрибут для идентификации элемента
            gate.setAttribute('data-element-id', element.id);
            
            // Применяем цвет/тип заполнения
            const fillColor = element && element.fillColor ? element.fillColor : globalFillColor;
            applyGateColor(gate, fillColor);
            
            // Убираем крышку над воротами - она не нужна
            
            // Добавляем обработчик клика
            gate.addEventListener('click', function(event) {
                event.stopPropagation(); // Предотвращаем всплытие события
                
                // Убираем выделение со всех элементов
                document.querySelectorAll('.fence-gate, .fence-span, .fence-post, .fence-wicket').forEach(g => g.classList.remove('selected'));
                removeAllSelectionHighlights();
                
                // Сбрасываем все переменные выбора
                selectedPole = null;
                selectedPoleElement = null;
                selectedSpan = null;
                selectedSpanElement = null;
                selectedWicket = null;
                selectedWicketElement = null;
                
                // Устанавливаем выбранные ворота
                selectedGate = element;
                selectedGateElement = this;
                
                this.classList.add('selected');
                addSelectionHighlight(this);
                console.log('Выбраны ворота:', this.id);
                
                // Открываем редактор ворот
                if (element) {
                    openFloatingEditor('gate', this, element);
                }
            });
            
            return gate
        }
        
        // Создание калитки как DOM-элемент
        function createWicketElement(x, y, element = null) {
            console.log('Создаем DOM-элемент калитки:', {x, y, element});
            const wicket = document.createElement('div');
            wicket.className = 'fence-wicket';
            wicket.id = `wicket${project.wicketCount + 1}`;
            
            const wicketHeight = element && element.height ? element.height * 20 : 160; // Используем высоту из элемента или по умолчанию
            const wicketWidth = element && element.width ? element.width : 100; // Используем ширину из элемента или по умолчанию
            
            wicket.style.cssText = `
                position: absolute;
                left: ${x}px;
                bottom: ${canvas.height - y + 30}px; /* Позиционируем от низа, выше линии земли */
                width: ${wicketWidth}px;
                height: ${wicketHeight}px; // Динамическая высота на основе element.height
                cursor: pointer;
                z-index: 50;
            `;
            
            // Добавляем атрибут для идентификации элемента
            wicket.setAttribute('data-element-id', element.id);
            
            // Применяем цвет заполнения из элемента или глобальный
            const fillColor = element && element.fillColor ? element.fillColor : globalFillColor;
            applyWicketColor(wicket, fillColor);
            
            // Убираем крышку над калиткой - она не нужна
            
            // Добавляем обработчик клика
            wicket.addEventListener('click', function(event) {
                event.stopPropagation(); // Предотвращаем всплытие события
                
                // Убираем выделение со всех элементов
                document.querySelectorAll('.fence-wicket, .fence-span, .fence-post, .fence-gate').forEach(w => w.classList.remove('selected'));
                removeAllSelectionHighlights();
                
                // Сбрасываем все переменные выбора
                selectedPole = null;
                selectedPoleElement = null;
                selectedSpan = null;
                selectedSpanElement = null;
                selectedGate = null;
                selectedGateElement = null;
                
                // Устанавливаем выбранную калитку
                selectedWicket = element;
                selectedWicketElement = this;
                
                this.classList.add('selected');
                addSelectionHighlight(this);
                console.log('Выбрана калитка:', this.id);
                
                // Открываем редактор калитки
                if (element) {
                    openFloatingEditor('wicket', this, element);
                }
            });
            
            return wicket
        }
        
        // Создание проема как DOM-элемент
        function createSpaceElement(x, y, element = null) {
            const space = document.createElement('div');
            space.className = 'fence-span';
            space.id = `space${project.spaceCount + 1}`;
            
            space.style.cssText = `
                position: absolute;
                left: ${x}px;
                bottom: ${canvas.height - y + 30}px;
                width: ${(element && element.width ? element.width : 100)}px;
                height: 20px;
                background: transparent;
                cursor: pointer;
                z-index: 50;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
                color: #999;
            `;
            
            if (element) space.setAttribute('data-element-id', element.id);
            space.textContent = `Проем ${(element && element.width ? (element.width/100).toFixed(1) : '1.0')}м`;
            
            // Добавляем обработчик клика
            space.addEventListener('click', function(event) {
                event.stopPropagation();
                document.querySelectorAll('.fence-post, .fence-span, .fence-gate, .fence-wicket').forEach(p => p.classList.remove('selected'));
                removeAllSelectionHighlights();

                // Выбор проема
                selectedPole = null;
                selectedPoleElement = null;
                selectedSpan = null;
                selectedSpanElement = null;
                selectedGate = null;
                selectedGateElement = null;
                selectedWicket = null;
                selectedWicketElement = null;

                // Найдём данные проёма по позиции
                const idx = Array.from(document.querySelectorAll('.fence-span')).indexOf(this);
                const model = project.elements.filter(el => el.type === 'space')[idx] || null;

                this.classList.add('selected');
                addSelectionHighlight(this);

                if (model) openFloatingEditor('space', this, model);
                console.log('Выбран проем:', this.id);
            });
            
            return space;
        }
        
        // Создание эпизода как DOM-элемент
        function createEpisodeElement(x, y, length) {
            const episode = document.createElement('div');
            episode.className = 'fence-span';
            episode.id = `episode${project.episodeCount + 1}`;
            
            episode.style.cssText = `
                position: absolute;
                left: ${x}px;
                bottom: ${canvas.height - y + 30}px;
                width: ${length}px;
                height: 50px;
                background: linear-gradient(45deg, #9370DB, #BA55D3);
                cursor: pointer;
                z-index: 50;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                color: white;
                font-weight: bold;
            `;
            
            episode.textContent = `${(length / 100).toFixed(1)}м`;
            
            // Добавляем обработчик клика
            episode.addEventListener('click', function() {
                document.querySelectorAll('.fence-span').forEach(e => e.classList.remove('selected'));
                this.classList.add('selected');
                console.log('Выбран эпизод:', this.id);
            });
            
            return episode;
        }
        
        // Пересчет общей длины на основе реальных элементов (как в линейке)
        function calculateTotalLength() {
            let totalLength = 0;
            
            project.elements.forEach(element => {
                if (element.type === 'pole') {
                    totalLength += 0.5; // Ширина столба 0.5м
                } else if (element.type === 'span') {
                    totalLength += element.width || 0; // Ширина пролета
                } else if (element.type === 'gate') {
                    totalLength += element.width || 0; // Ширина ворот
                } else if (element.type === 'wicket') {
                    totalLength += element.width || 0; // Ширина калитки
                } else if (element.type === 'space') {
                    totalLength += element.width || 0; // Ширина проема
                }
            });
            
            return totalLength;
        }
        
        // Функция для получения длины из линейки (синхронизация)
        function getRulerTotalLength() {
            const rulerEl = document.querySelector('.fence-ruler');
            if (rulerEl) {
                const totalEl = rulerEl.querySelector('.fence-ruler-total');
                if (totalEl) {
                    // Извлекаем число из текста "XX.XX м"
                    const text = totalEl.textContent;
                    const match = text.match(/(\d+\.?\d*)/);
                    if (match) {
                        return parseFloat(match[1]);
                    }
                }
            }
            return calculateTotalLength(); // Fallback на расчет
        }
        
        // Обновление информации
        function updateInfo() {
            // Пересчитываем общую длину на основе реальных элементов
            project.totalLength = calculateTotalLength();
            
            const totalLengthEl = document.getElementById('totalLength');
            const poleCountEl = document.getElementById('poleCount');
            const panelCountEl = document.getElementById('panelCount');
            const wicketCountEl = document.getElementById('wicketCount');
            const gateCountEl = document.getElementById('gateCount');
            
            // Используем длину из линейки для синхронизации
            const rulerLength = getRulerTotalLength();
            if (totalLengthEl) totalLengthEl.textContent = rulerLength.toFixed(2) + ' м';
            if (poleCountEl) poleCountEl.textContent = project.poleCount;
            if (panelCountEl) panelCountEl.textContent = project.panelCount;
            if (wicketCountEl) wicketCountEl.textContent = project.wicketCount;
            if (gateCountEl) gateCountEl.textContent = project.gateCount;
            
            // Подсчёт блоков и крышек
            let blocks = 0;
            let caps = 0;
            project.elements.forEach(el => {
                if (el.type === 'pole') {
                    const h = el.height || 0;
                    blocks += h; // по 1 блоку на ряд в столбе (ширина 1 блок)
                    caps += 1;   // 1 крышка на столб
                } else if (el.type === 'panel') {
                    const rows = el.rows || 1;
                    const blocksPerRow = Math.floor(((typeof el.length === 'number' ? el.length : 0) / 50));
                    blocks += rows * blocksPerRow;
                    caps += blocksPerRow; // крышки над верхним рядом
                }
            });

            const blockCountEl = document.getElementById('blockCount');
            const capCountEl = document.getElementById('capCount');
            if (blockCountEl) blockCountEl.textContent = blocks.toString();
            if (capCountEl) capCountEl.textContent = caps.toString();
        }
        
        // Обновление индикатора масштаба
        function updateZoomIndicator() {
            const zoomIndicator = document.getElementById('zoomIndicator');
            if (zoomIndicator) {
                const zoomPercent = Math.round(zoom * 100);
                zoomIndicator.textContent = `Масштаб: ${zoomPercent}%`;
            }
        }
        
        // Функции управления проектом
        function saveProject() {
            console.log('=== НАЧАЛО СОХРАНЕНИЯ ПРОЕКТА ===');
            
            try {
                // Простая проверка доступности элементов
                const fenceViewport = document.getElementById('fenceViewport');
                const mainCanvas = document.querySelector('.main-canvas');
                const canvas = document.getElementById('canvas');
                
                console.log('Проверка элементов:');
                console.log('- fenceViewport:', !!fenceViewport);
                console.log('- mainCanvas:', !!mainCanvas);
                console.log('- canvas:', !!canvas);
                
                // Если нет никаких элементов для скриншота
                if (!canvas && !fenceViewport && !mainCanvas) {
                    alert('Ошибка: не найдены элементы для создания скриншота');
                    return;
                }
                
                // Создаем водяные знаки для сохранения
                console.log('Добавление водяных знаков...');
                addWatermarks();
                
                // Увеличиваем время ожидания для стабильности
                setTimeout(() => {
                    try {
                        console.log('Попытка создания простого скриншота...');
                        // Попробуем простой метод сначала
                        createSimpleScreenshot();
                    } catch (error) {
                        console.error('Ошибка при создании скриншота:', error);
                        console.error('Stack trace:', error.stack);
                        removeWatermarks();
                        alert('Ошибка при сохранении скриншота: ' + error.message);
                    }
                }, 200); // Увеличили время ожидания
            } catch (error) {
                console.error('Ошибка в saveProject:', error);
                console.error('Stack trace:', error.stack);
                alert('Ошибка при инициализации сохранения: ' + error.message);
            }
        }
        
        // Простой метод скриншота
        function createSimpleScreenshot() {
            console.log('=== СОЗДАНИЕ ПРОСТОГО СКРИНШОТА ===');
            
            try {
                // Проверяем есть ли элементы забора
                const hasElements = project.elements && project.elements.length > 0;
                console.log('Элементы забора на полотне:', hasElements, 'количество:', project.elements?.length || 0);
                
                // ВСЕГДА пробуем сначала html2canvas для сохранения реального забора пользователя
                console.log('Пробуем html2canvas для сохранения реального забора пользователя...');
                createHtml2CanvasScreenshotWithRetry();
                
            } catch (error) {
                console.error('Ошибка в createSimpleScreenshot:', error);
                fallbackToCanvasOnly();
            }
        }
        
        // Диагностика видимости элементов перед скриншотом
        function diagnoseFenceVisibility() {
            console.log('=== ДИАГНОСТИКА ВИДИМОСТИ ЭЛЕМЕНТОВ ===');
            
            const fenceViewport = document.getElementById('fenceViewport');
            const mainCanvas = document.querySelector('.main-canvas');
            const fenceElements = document.querySelectorAll('.fence-element');
            
            console.log('fenceViewport:', fenceViewport ? 'найден' : 'НЕ НАЙДЕН');
            console.log('mainCanvas:', mainCanvas ? 'найден' : 'НЕ НАЙДЕН');
            console.log('Количество fence-element на странице:', fenceElements.length);
            
            if (fenceViewport) {
                const rect = fenceViewport.getBoundingClientRect();
                console.log('fenceViewport размеры:', rect.width, 'x', rect.height);
                console.log('fenceViewport позиция:', rect.left, rect.top);
                console.log('fenceViewport видимость:', getComputedStyle(fenceViewport).visibility);
                console.log('fenceViewport display:', getComputedStyle(fenceViewport).display);
                console.log('fenceViewport opacity:', getComputedStyle(fenceViewport).opacity);
            }
            
            fenceElements.forEach((element, index) => {
                const rect = element.getBoundingClientRect();
                const style = getComputedStyle(element);
                console.log(`Элемент ${index + 1}:`, {
                    className: element.className,
                    размеры: `${rect.width}x${rect.height}`,
                    позиция: `${rect.left},${rect.top}`,
                    видимость: style.visibility,
                    display: style.display,
                    opacity: style.opacity,
                    zIndex: style.zIndex
                });
            });
        }

        // Улучшенный метод html2canvas с несколькими попытками
        function createHtml2CanvasScreenshotWithRetry() {
            console.log('=== HTML2CANVAS С ПОВТОРНЫМИ ПОПЫТКАМИ ===');
            
            // Сначала диагностируем видимость
            diagnoseFenceVisibility();
            
            // Пробуем разные конфигурации html2canvas
            const configs = [
                {
                    name: 'Полная конфигурация для забора',
                    options: {
                        backgroundColor: '#87CEEB',
                        scale: 1,
                        useCORS: true,
                        allowTaint: true,
                        logging: true,
                        removeContainer: false,
                        foreignObjectRendering: true,
                        ignoreElements: function(element) {
                            // Игнорируем только служебные элементы, НЕ элементы забора
                            return element.classList.contains('watermark-tile') || 
                                   element.classList.contains('sidebar') ||
                                   element.classList.contains('top-controls');
                        },
                        onclone: function(clonedDoc) {
                            console.log('HTML2Canvas клонирование завершено');
                            const clonedElements = clonedDoc.querySelectorAll('.fence-element');
                            console.log('Элементов забора в клоне:', clonedElements.length);
                            
                            // Убираем 3D трансформации для лучшего захвата
                            const clonedViewport = clonedDoc.getElementById('fenceViewport');
                            if (clonedViewport) {
                                clonedViewport.style.transform = 'none';
                                clonedViewport.style.perspective = 'none';
                            }
                        }
                    }
                },
                {
                    name: 'Конфигурация без 3D эффектов',
                    options: {
                        backgroundColor: '#87CEEB',
                        scale: 1,
                        useCORS: true,
                        allowTaint: true,
                        logging: true,
                        removeContainer: false,
                        foreignObjectRendering: false,
                        onclone: function(clonedDoc) {
                            // Убираем все 3D трансформации
                            const allElements = clonedDoc.querySelectorAll('*');
                            allElements.forEach(el => {
                                if (el.style) {
                                    el.style.transform = 'none';
                                    el.style.perspective = 'none';
                                    el.style.transformStyle = 'flat';
                                }
                            });
                        }
                    }
                },
                {
                    name: 'Стандартная конфигурация',
                    options: {
                        backgroundColor: null, // Прозрачный фон
                        scale: 1,
                        useCORS: true,
                        allowTaint: true,
                        logging: true,
                        removeContainer: false,
                        foreignObjectRendering: false
                    }
                },
                {
                    name: 'Простая конфигурация',
                    options: {
                        scale: 1,
                        logging: false
                    }
                }
            ];
            
            tryHtml2CanvasWithConfig(0, configs);
        }
        
        // Рекурсивная функция для попыток с разными конфигурациями
        function tryHtml2CanvasWithConfig(configIndex, configs) {
            if (configIndex >= configs.length) {
                console.log('Все конфигурации html2canvas неудачны, переходим к canvas методу...');
                createCanvasScreenshot();
                return;
            }
            
            const config = configs[configIndex];
            console.log(`Попытка ${configIndex + 1}/${configs.length}: ${config.name}`);
            
            try {
                const fenceViewport = document.getElementById('fenceViewport');
                const mainCanvas = document.querySelector('.main-canvas');
                const targetElement = fenceViewport || mainCanvas;
                
                if (!targetElement) {
                    throw new Error('Не найден элемент для скриншота');
                }
                
                console.log(`Конфигурация ${configIndex + 1} - Target:`, targetElement.tagName, targetElement.id || targetElement.className);
                console.log(`Конфигурация ${configIndex + 1} - Размеры:`, targetElement.offsetWidth, 'x', targetElement.offsetHeight);
                console.log(`Конфигурация ${configIndex + 1} - Опции:`, config.options);
                
                if (typeof html2canvas !== 'undefined') {
                    html2canvas(targetElement, config.options).then(screenshotCanvas => {
                        console.log(`✓ HTML2Canvas конфигурация ${configIndex + 1} успешна!`);
                        console.log('Размер результата:', screenshotCanvas.width, 'x', screenshotCanvas.height);
                        
                        // Проверяем что canvas не пустой
                        const ctx = screenshotCanvas.getContext('2d');
                        const imageData = ctx.getImageData(0, 0, screenshotCanvas.width, screenshotCanvas.height);
                        const data = imageData.data;
                        let hasContent = false;
                        
                        // Проверяем есть ли непрозрачные пиксели
                        for (let i = 3; i < data.length; i += 4) {
                            if (data[i] > 0) {
                                hasContent = true;
                                break;
                            }
                        }
                        
                        if (hasContent) {
                            console.log('✓ Скриншот содержит данные, сохраняем...');
                            saveScreenshotCanvas(screenshotCanvas, `html2canvas-config-${configIndex + 1}`);
                        } else {
                            console.log('⚠ Скриншот пустой, пробуем следующую конфигурацию...');
                            tryHtml2CanvasWithConfig(configIndex + 1, configs);
                        }
                        
                    }).catch(error => {
                        console.error(`Ошибка html2canvas конфигурации ${configIndex + 1}:`, error);
                        tryHtml2CanvasWithConfig(configIndex + 1, configs);
                    });
                } else {
                    console.error('html2canvas не доступен');
                    createCanvasScreenshot();
                }
                
            } catch (error) {
                console.error(`Ошибка в конфигурации ${configIndex + 1}:`, error);
                tryHtml2CanvasWithConfig(configIndex + 1, configs);
            }
        }

        // Метод скриншота через html2canvas (для пустого полотна)
        function createHtml2CanvasScreenshot() {
            try {
                // Находим лучший элемент для скриншота
                const fenceViewport = document.getElementById('fenceViewport');
                const mainCanvas = document.querySelector('.main-canvas');
                const targetElement = fenceViewport || mainCanvas;
                
                if (!targetElement) {
                    throw new Error('Не найден элемент для скриншота');
                }
                
                console.log('HTML2Canvas - Target element:', targetElement.tagName, targetElement.id || targetElement.className);
                console.log('HTML2Canvas - Размеры:', targetElement.offsetWidth, 'x', targetElement.offsetHeight);
                
                // Используем html2canvas напрямую с простыми настройками
                if (typeof html2canvas !== 'undefined') {
                    console.log('Запуск html2canvas...');
                    
                    html2canvas(targetElement, {
                        backgroundColor: '#87CEEB', // Голубой фон по умолчанию
                        scale: 1,
                        useCORS: true,
                        allowTaint: true,
                        logging: false
                    }).then(screenshotCanvas => {
                        console.log('✓ HTML2Canvas успешно завершен!');
                        console.log('Размер результата:', screenshotCanvas.width, 'x', screenshotCanvas.height);
                        
                        saveScreenshotCanvas(screenshotCanvas, 'html2canvas');
                        
                    }).catch(error => {
                        console.error('Ошибка html2canvas:', error);
                        console.log('Переход к canvas методу...');
                        createCanvasScreenshot();
                    });
                } else {
                    console.error('html2canvas не доступен');
                    createCanvasScreenshot();
                }
                
            } catch (error) {
                console.error('Ошибка в createHtml2CanvasScreenshot:', error);
                createCanvasScreenshot();
            }
        }
        
        // Метод скриншота рисованием на canvas (для полотна с элементами)
        function createCanvasScreenshot() {
            console.log('=== СОЗДАНИЕ CANVAS СКРИНШОТА ===');
            
            try {
                const targetElement = document.getElementById('fenceViewport') || document.querySelector('.main-canvas');
                if (!targetElement) {
                    throw new Error('Не найден контейнер для скриншота');
                }
                
                // Создаем canvas для скриншота
                const screenshotCanvas = document.createElement('canvas');
                const ctx = screenshotCanvas.getContext('2d');
                
                // Устанавливаем размеры
                screenshotCanvas.width = targetElement.offsetWidth || 1200;
                screenshotCanvas.height = targetElement.offsetHeight || 800;
                
                console.log('Canvas скриншот - размеры:', screenshotCanvas.width, 'x', screenshotCanvas.height);
                
                // 1. Рисуем фон
                drawBackgroundOnCanvas(ctx, screenshotCanvas.width, screenshotCanvas.height);
                
                // 2. Рисуем линию земли
                drawGroundLineOnCanvas(ctx, screenshotCanvas.width, screenshotCanvas.height);
                
                // 3. Рисуем элементы забора
                drawFenceElementsOnCanvas(ctx, screenshotCanvas.width, screenshotCanvas.height);
                
                // 4. Рисуем водяные знаки
                drawWatermarksOnCanvas(ctx, screenshotCanvas.width, screenshotCanvas.height);
                
                console.log('✓ Canvas скриншот создан!');
                saveScreenshotCanvas(screenshotCanvas, 'canvas');
                
            } catch (error) {
                console.error('Ошибка создания canvas скриншота:', error);
                console.error('Canvas error stack:', error.stack);
                fallbackToCanvasOnly();
            }
        }
        
        // Общая функция сохранения canvas
        function saveScreenshotCanvas(canvas, method) {
            try {
                console.log(`Сохранение canvas (метод: ${method})...`);
                
                const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
                const dataUrl = canvas.toDataURL('image/png', 1.0);
                
                console.log('DataURL создан, длина:', dataUrl.length);
                
                const link = document.createElement('a');
                link.download = `fence_project_${timestamp}.png`;
                link.href = dataUrl;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                removeWatermarks();
                console.log(`✓ Скриншот сохранен методом ${method}!`);
                alert('Скриншот сохранен в папку Загрузки!');
                
            } catch (saveError) {
                console.error(`Ошибка при сохранении canvas (${method}):`, saveError);
                removeWatermarks();
                alert('Ошибка при сохранении файла: ' + saveError.message);
            }
        }
        
        // Рисование фона на canvas
        function drawBackgroundOnCanvas(ctx, width, height) {
            console.log('Рисование фона...');
            
            // Проверяем есть ли пользовательское изображение
            if (customBackgroundImage && customBackgroundImage.complete) {
                console.log('Рисуем пользовательское фоновое изображение');
                ctx.drawImage(customBackgroundImage, 0, 0, width, height);
            } else {
                // Рисуем стандартный градиентный фон
                console.log('Рисуем стандартный градиентный фон');
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.5, '#87CEEB');
                gradient.addColorStop(1, '#4682B4');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
            }
        }
        
        // Рисование линии земли на canvas
        function drawGroundLineOnCanvas(ctx, width, height) {
            console.log('Рисование линии земли...');
            
            const groundY = height / 2;
            const groundHeight = 30;
            
            // Определяем прозрачность в зависимости от наличия фона
            const hasBackground = customBackgroundImage && customBackgroundImage.complete;
            const opacity = hasBackground ? 0.8 : 0.5;
            
            // Создаем градиент для линии земли
            const groundGradient = ctx.createLinearGradient(0, groundY - groundHeight/2, 0, groundY + groundHeight/2);
            groundGradient.addColorStop(0, `rgba(74, 74, 74, ${opacity})`);
            groundGradient.addColorStop(0.45, `rgba(59, 47, 34, ${opacity})`);
            groundGradient.addColorStop(1, `rgba(43, 34, 15, ${opacity})`);
            
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, groundY - groundHeight/2, width, groundHeight);
            
            console.log(`Линия земли нарисована с прозрачностью ${opacity * 100}%`);
        }
        
        // Рисование элементов забора на canvas
        function drawFenceElementsOnCanvas(ctx, width, height) {
            console.log('Рисование элементов забора...');
            
            if (!project.elements || project.elements.length === 0) {
                console.log('Нет элементов забора для рисования');
                return;
            }
            
            const groundY = height / 2;
            const scale = 1; // Масштаб рисования
            
            project.elements.forEach((element, index) => {
                try {
                    console.log(`Рисуем элемент ${index + 1}/${project.elements.length}:`, element.type, element.length + 'м');
                    
                    const elementX = (element.x || 0) * scale;
                    const elementY = groundY;
                    const elementWidth = (element.length || 2.5) * 100 * scale; // 1м = 100px
                    const elementHeight = (element.height || 2) * 100 * scale;
                    
                    // Рисуем основной элемент в зависимости от типа
                    switch (element.type) {
                        case 'pole':
                            drawPoleOnCanvas(ctx, elementX, elementY - elementHeight, 50 * scale, elementHeight, element);
                            break;
                        case 'span':
                            drawSpanOnCanvas(ctx, elementX, elementY - elementHeight, elementWidth, elementHeight, element);
                            break;
                        case 'gate':
                            drawGateOnCanvas(ctx, elementX, elementY - elementHeight, elementWidth, elementHeight, element);
                            break;
                        case 'wicket':
                            drawWicketOnCanvas(ctx, elementX, elementY - elementHeight, elementWidth, elementHeight, element);
                            break;
                    }
                } catch (elementError) {
                    console.error(`Ошибка при рисовании элемента ${index}:`, elementError);
                }
            });
            
            console.log('Элементы забора нарисованы');
        }
        
        // Рисование столба на canvas
        function drawPoleOnCanvas(ctx, x, y, width, height, element) {
            // Рисуем столб серым цветом
            ctx.fillStyle = '#888';
            ctx.fillRect(x, y, width, height);
            
            // Добавляем границу
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
        }
        
        // Рисование пролета на canvas
        function drawSpanOnCanvas(ctx, x, y, width, height, element) {
            // Рисуем основу пролета
            ctx.fillStyle = '#666';
            ctx.fillRect(x, y, width, height);
            
            // Рисуем блоки
            const blockHeight = 20;
            const rows = Math.floor(height / blockHeight);
            const blocksPerRow = Math.floor(width / 50);
            
            for (let row = 0; row < rows; row++) {
                for (let block = 0; block < blocksPerRow; block++) {
                    const blockX = x + (block * 50);
                    const blockY = y + (row * blockHeight);
                    
                    // Рисуем блок с небольшой вариацией цвета
                    const shade = 100 + (Math.random() * 50);
                    ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
                    ctx.fillRect(blockX, blockY, 48, 18);
                    
                    // Граница блока
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(blockX, blockY, 48, 18);
                }
            }
        }
        
        // Рисование ворот на canvas
        function drawGateOnCanvas(ctx, x, y, width, height, element) {
            // Рисуем ворота фиолетовым цветом
            ctx.fillStyle = '#9370DB';
            ctx.fillRect(x, y, width, height);
            
            // Добавляем текст "ВОРОТА"
            ctx.fillStyle = '#FFF';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ВОРОТА', x + width/2, y + height/2 + 6);
        }
        
        // Рисование калитки на canvas
        function drawWicketOnCanvas(ctx, x, y, width, height, element) {
            // Рисуем калитку зеленым цветом
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(x, y, width, height);
            
            // Добавляем текст "КАЛИТКА"
            ctx.fillStyle = '#FFF';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('КАЛИТКА', x + width/2, y + height/2 + 5);
        }
        
        // Рисование водяных знаков на canvas
        function drawWatermarksOnCanvas(ctx, width, height) {
            console.log('Рисование водяных знаков...');
            
            ctx.save();
            
            // Настройки водяных знаков
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            
            const text = 'plitochka.by';
            const spacing = 200;
            
            // Поворачиваем на -45 градусов
            ctx.rotate(-Math.PI / 4);
            
            // Рисуем водяные знаки по диагонали
            for (let x = -width; x < width * 2; x += spacing) {
                for (let y = -height; y < height * 2; y += spacing) {
                    ctx.fillText(text, x, y);
                }
            }
            
            ctx.restore();
            console.log('Водяные знаки нарисованы');
        }

        // Fallback только для основного canvas
        function fallbackToCanvasOnly() {
            console.log('=== FALLBACK К CANVAS ===');
            
            try {
                const canvas = document.getElementById('canvas');
                console.log('Canvas элемент:', canvas);
                console.log('Canvas найден:', !!canvas);
                
                if (canvas) {
                    console.log('Canvas размеры:', canvas.width, 'x', canvas.height);
                    console.log('Canvas style:', canvas.style.cssText);
                    console.log('Canvas parent:', canvas.parentElement);
                }
                
                if (canvas && canvas.width > 0 && canvas.height > 0) {
                    console.log('✓ Canvas валидный, начинаем сохранение...');
                    
                    try {
                        // Проверяем возможность создания dataURL
                        console.log('Создание dataURL...');
                        const dataUrl = canvas.toDataURL('image/png', 1.0);
                        console.log('DataURL создан, длина:', dataUrl.length);
                        
                        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
                        console.log('Timestamp:', timestamp);
                        
                        const link = document.createElement('a');
                        link.download = `fence_background_${timestamp}.png`;
                        link.href = dataUrl;
                        
                        console.log('Создана ссылка для скачивания:', link.download);
                        console.log('Href длина:', link.href.length);
                        
                        document.body.appendChild(link);
                        console.log('Ссылка добавлена в DOM');
                        
                        link.click();
                        console.log('Клик по ссылке выполнен');
                        
                        document.body.removeChild(link);
                        console.log('Ссылка удалена из DOM');
                        
                        removeWatermarks();
                        console.log('✓ Водяные знаки удалены');
                        
                        alert('Сохранен фоновый canvas в папку Загрузки!');
                        
                    } catch (saveError) {
                        console.error('Ошибка при сохранении canvas:', saveError);
                        console.error('Save error stack:', saveError.stack);
                        removeWatermarks();
                        alert('Ошибка при создании файла: ' + saveError.message);
                    }
                    
                } else {
                    console.error('Canvas не найден или имеет нулевые размеры');
                    console.log('Canvas состояние:', {
                        found: !!canvas,
                        width: canvas?.width,
                        height: canvas?.height
                    });
                    
                    removeWatermarks();
                    alert('Ошибка: нет данных для сохранения. Попробуйте загрузить фоновое изображение или добавить элементы забора.');
                }
            } catch (error) {
                console.error('Критическая ошибка fallback:', error);
                console.error('Critical error stack:', error.stack);
                removeWatermarks();
                alert('Критическая ошибка при сохранении: ' + error.message);
            }
        }
        
        // Функция создания композитного скриншота
        function createCompositeScreenshot() {
            console.log('=== Начало createCompositeScreenshot ===');
            
            try {
                // Находим полотно с забором
                const fenceViewport = document.getElementById('fenceViewport');
                const mainCanvas = document.querySelector('.main-canvas');
                const canvas = document.getElementById('canvas');
                const targetElement = fenceViewport || mainCanvas;
                
                console.log('Элементы найдены:');
                console.log('- fenceViewport:', !!fenceViewport, fenceViewport?.id);
                console.log('- mainCanvas:', !!mainCanvas, mainCanvas?.className);
                console.log('- canvas:', !!canvas, canvas?.id);
                console.log('- targetElement:', !!targetElement);
                
                if (targetElement) {
                    console.log('Размеры targetElement:', targetElement.offsetWidth, 'x', targetElement.offsetHeight);
                    console.log('Позиция targetElement:', targetElement.offsetLeft, ',', targetElement.offsetTop);
                }
                
                if (!targetElement) {
                    console.error('ОШИБКА: не найден контейнер с забором');
                    alert('Ошибка: не найден контейнер с забором');
                    removeWatermarks();
                    return;
                }
                
                // Проверяем, что элемент имеет размеры
                if (targetElement.offsetWidth === 0 || targetElement.offsetHeight === 0) {
                    console.error('ОШИБКА: полотно с забором не имеет размеров');
                    alert('Ошибка: полотно с забором не имеет размеров');
                    removeWatermarks();
                    return;
                }
                
                // Создаем композитный canvas
                console.log('Создание композитного canvas...');
                const compositeCanvas = document.createElement('canvas');
                const compositeCtx = compositeCanvas.getContext('2d');
                
                if (!compositeCtx) {
                    throw new Error('Не удалось создать контекст 2D для canvas');
                }
                
                // Устанавливаем размеры композитного canvas
                compositeCanvas.width = targetElement.offsetWidth;
                compositeCanvas.height = targetElement.offsetHeight;
                
                console.log('Композитный canvas создан. Размеры:', compositeCanvas.width, 'x', compositeCanvas.height);
                
                // 1. Рисуем фон (canvas с загруженной картинкой)
                console.log('Рисование фона...');
                if (canvas && canvas.width > 0 && canvas.height > 0) {
                    console.log('Фоновый canvas найден, размеры:', canvas.width, 'x', canvas.height);
                    try {
                        // Масштабируем фоновый canvas под размеры target element
                        compositeCtx.drawImage(canvas, 0, 0, compositeCanvas.width, compositeCanvas.height);
                        console.log('✓ Фоновый canvas отрисован');
                    } catch (drawError) {
                        console.error('Ошибка при рисовании фонового canvas:', drawError);
                        throw drawError;
                    }
                } else {
                    console.log('Фоновый canvas не найден или пуст, рисуем стандартный фон');
                    try {
                        // Заливаем стандартным фоном если нет загруженной картинки
                        const gradient = compositeCtx.createLinearGradient(0, 0, 0, compositeCanvas.height);
                        gradient.addColorStop(0, '#87CEEB');
                        gradient.addColorStop(0.5, '#87CEEB');
                        gradient.addColorStop(1, '#4682B4');
                        compositeCtx.fillStyle = gradient;
                        compositeCtx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
                        console.log('✓ Стандартный фон отрисован');
                    } catch (gradientError) {
                        console.error('Ошибка при создании градиента:', gradientError);
                        throw gradientError;
                    }
                }
                
                // 2. Накладываем DOM-элементы (забор + водяные знаки) через html2canvas
                console.log('Проверка html2canvas...');
                console.log('html2canvas доступен:', typeof html2canvas !== 'undefined');
                
                if (typeof html2canvas !== 'undefined') {
                    console.log('Запуск html2canvas для targetElement...');
                    console.log('targetElement для html2canvas:', targetElement.tagName, targetElement.id, targetElement.className);
                    
                    const html2canvasOptions = {
                        backgroundColor: null, // Прозрачный фон
                        scale: 1,
                        useCORS: true,
                        allowTaint: true,
                        logging: false, // Отключаем внутреннее логирование html2canvas
                        width: targetElement.offsetWidth,
                        height: targetElement.offsetHeight,
                        scrollX: 0,
                        scrollY: 0,
                        x: 0,
                        y: 0,
                        foreignObjectRendering: true,
                        timeout: 30000 // 30 секунд таймаут
                    };
                    
                    console.log('Опции html2canvas:', html2canvasOptions);
                    
                    html2canvas(targetElement, html2canvasOptions).then(domCanvas => {
                        console.log('✓ DOM-элементы успешно захвачены!');
                        console.log('Размер DOM canvas:', domCanvas.width, 'x', domCanvas.height);
                        
                        try {
                            // Накладываем DOM-элементы поверх фона
                            compositeCtx.drawImage(domCanvas, 0, 0);
                            console.log('✓ DOM-элементы успешно наложены на композитный canvas');
                            
                            // Сохраняем композитный результат
                            saveCompositeCanvas(compositeCanvas);
                        } catch (compositeError) {
                            console.error('Ошибка при композиции:', compositeError);
                            // Fallback - сохраняем только фон
                            console.log('Fallback: сохраняем только фон');
                            saveCompositeCanvas(compositeCanvas);
                        }
                        
                    }).catch(error => {
                        console.error('Ошибка html2canvas при захвате DOM:', error);
                        console.error('html2canvas error stack:', error.stack);
                        // Fallback - сохраняем только фон
                        console.log('Fallback: сохраняем только фон из-за ошибки html2canvas');
                        saveCompositeCanvas(compositeCanvas);
                    });
                } else {
                    console.warn('html2canvas не найден, сохраняем только фон');
                    saveCompositeCanvas(compositeCanvas);
                }
            } catch (error) {
                console.error('Ошибка при создании композитного скриншота:', error);
                console.error('Stack trace:', error.stack);
                removeWatermarks();
                
                // Простой fallback - используем только основной canvas
                console.log('Переход к простому fallback методу...');
                try {
                    const canvas = document.getElementById('canvas');
                    if (canvas && canvas.width > 0 && canvas.height > 0) {
                        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
                        const link = document.createElement('a');
                        link.download = `fence_project_${timestamp}.png`;
                        link.href = canvas.toDataURL('image/png', 1.0);
                        
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        alert('Скриншот фона сохранен в папку Загрузки!');
                    } else {
                        alert('Ошибка: не удалось создать скриншот. Попробуйте загрузить фоновое изображение.');
                    }
                } catch (fallbackError) {
                    console.error('Ошибка fallback метода:', fallbackError);
                    alert('Критическая ошибка при сохранении скриншота: ' + fallbackError.message);
                }
            }
        }
        
        // Функция сохранения композитного canvas
        function saveCompositeCanvas(canvas) {
            try {
                console.log('Сохранение композитного canvas...');
                
                // Создаем ссылку для скачивания
                const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
                const link = document.createElement('a');
                link.download = `fence_project_${timestamp}.png`;
                link.href = canvas.toDataURL('image/png', 1.0); // Максимальное качество
                
                // Программно кликаем по ссылке для скачивания
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Удаляем временные водяные знаки
                removeWatermarks();
                
                console.log('Композитный скриншот сохранен');
                alert('Скриншот полотна с забором и фоном сохранен в папку Загрузки!');
                
            } catch (error) {
                console.error('Ошибка при сохранении композитного canvas:', error);
                removeWatermarks();
                alert('Ошибка при сохранении скриншота');
            }
        }
        
        // Fallback функция для старого метода скриншота
        function fallbackScreenshot() {
            try {
                // Находим полотно с забором - приоритет fenceViewport
                const fenceViewport = document.getElementById('fenceViewport');
                const mainCanvas = document.querySelector('.main-canvas');
                const targetElement = fenceViewport || mainCanvas;
                
                if (!targetElement) {
                    alert('Ошибка: не найден контейнер с забором');
                    removeWatermarks();
                    return;
                }
                
                // Используем старый метод скриншота
                tryAlternativeScreenshot();
            } catch (error) {
                console.error('Ошибка в fallbackScreenshot:', error);
                removeWatermarks();
                alert('Ошибка при сохранении скриншота');
            }
        }
        
        // Альтернативный способ создания скриншота
        function tryAlternativeScreenshot() {
            try {
                // Находим полотно с забором
                const fenceViewport = document.getElementById('fenceViewport');
                const mainCanvas = document.querySelector('.main-canvas');
                const targetElement = fenceViewport || mainCanvas;
                
                if (!targetElement) {
                    alert('Ошибка: не найден контейнер с забором');
                    removeWatermarks();
                    return;
                }
                
                // Способ 2: Используем dom-to-image
                if (typeof domtoimage !== 'undefined') {
                    domtoimage.toPng(targetElement, {
                        quality: 1.0, // Максимальное качество
                        bgcolor: '#1a1a1a',
                        width: targetElement.offsetWidth,
                        height: targetElement.offsetHeight,
                        style: {
                            transform: 'scale(1)',
                            transformOrigin: 'top left'
                        }
                    }).then(function (dataUrl) {
                        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
                        const link = document.createElement('a');
                        link.download = `fence_project_${timestamp}.png`;
                        link.href = dataUrl;
                        
                        // Программно кликаем по ссылке для скачивания
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        removeWatermarks();
                        alert('Скриншот полотна с забором сохранен в папку Загрузки!');
                    }).catch(function (error) {
                        console.error('Ошибка dom-to-image:', error);
                        // Способ 3: Простой canvas
                        trySimpleCanvas();
                    });
                } else {
                    // Способ 3: Простой canvas
                    trySimpleCanvas();
                }
            } catch (error) {
                console.error('Ошибка альтернативного скриншота:', error);
                // Способ 3: Простой canvas
                trySimpleCanvas();
            }
        }
        
        // Простой способ через canvas
        function trySimpleCanvas() {
            try {
                // Способ 3: Рисуем забор на canvas вручную
                drawFenceToCanvas();
            } catch (error) {
                console.error('Ошибка простого canvas:', error);
                // Способ 4: Последний fallback
                tryBuiltInScreenshot();
            }
        }
        
        // Рисуем забор на canvas вручную
        function drawFenceToCanvas() {
            try {
                // Создаем canvas для скриншота
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Устанавливаем размеры canvas
                canvas.width = 1200;
                canvas.height = 800;
                
                // Заливаем фон
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.5, '#87CEEB');
                gradient.addColorStop(1, '#4682B4');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Рисуем линию земли
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
                
                // Рисуем элементы забора
                let currentX = 100;
                const groundY = canvas.height / 2;
                
                project.elements.forEach(element => {
                    if (element.type === 'pole') {
                        drawPoleToCanvas(ctx, currentX, groundY, element);
                        currentX += 50; // Ширина столба
                    } else if (element.type === 'span') {
                        drawSpanToCanvas(ctx, currentX, groundY, element);
                        currentX += element.width * 100; // Ширина пролета в пикселях
                    } else if (element.type === 'gate') {
                        drawGateToCanvas(ctx, currentX, groundY, element);
                        currentX += element.width * 100;
                    } else if (element.type === 'wicket') {
                        drawWicketToCanvas(ctx, currentX, groundY, element);
                        currentX += element.width * 100;
                    }
                });
                
                // Рисуем водяные знаки
                drawWatermarksToCanvas(ctx, canvas.width, canvas.height);
                
                // Создаем ссылку для скачивания
                const link = document.createElement('a');
                link.download = 'fence_project_' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                
                removeWatermarks();
                alert('Скриншот проекта сохранен!');
                
            } catch (error) {
                console.error('Ошибка рисования на canvas:', error);
                tryBuiltInScreenshot();
            }
        }
        
        // Встроенный API для скриншотов
        function tryBuiltInScreenshot() {
            try {
                // Создаем временный canvas для захвата
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Рисуем текущее состояние страницы
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Рисуем элементы забора
                drawFenceElementsToCanvas(ctx, canvas.width, canvas.height);
                
                // Рисуем водяные знаки
                drawWatermarksToCanvas(ctx, canvas.width, canvas.height);
                
                // Сохраняем
                const link = document.createElement('a');
                link.download = 'fence_project_' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                
                removeWatermarks();
                alert('Скриншот проекта сохранен!');
            } catch (error) {
                console.error('Ошибка встроенного API:', error);
                removeWatermarks();
                saveProjectAsJSON();
            }
        }
        
        // Функция для ручного скриншота
        function manualScreenshot() {
            // Создаем водяные знаки
            addWatermarks();
            
            // Показываем инструкцию
            alert('Инструкция для создания скриншота:\n\n' +
                  '1. Нажмите Ctrl+Shift+S (Windows) или Cmd+Shift+S (Mac)\n' +
                  '2. Или используйте встроенную функцию браузера:\n' +
                  '   - Chrome: Ctrl+Shift+I → Console → нажмите на иконку камеры\n' +
                  '   - Firefox: Ctrl+Shift+K → Console → нажмите на иконку камеры\n' +
                  '   - Edge: Ctrl+Shift+I → Console → нажмите на иконку камеры\n\n' +
                  '3. Или используйте Print Screen (PrtScn) и вставьте в Paint\n\n' +
                  'Водяные знаки уже добавлены на страницу!');
            
            // Удаляем водяные знаки через 10 секунд
            setTimeout(() => {
                removeWatermarks();
            }, 10000);
        }
        
        // Функция для сохранения проекта как JSON (fallback)
        function saveProjectAsJSON() {
            try {
                const projectData = {
                    elements: project.elements,
                    totalLength: project.totalLength,
                    poleCount: project.poleCount,
                    panelCount: project.panelCount,
                    wicketCount: project.wicketCount,
                    gateCount: project.gateCount,
                    spaceCount: project.spaceCount,
                    episodeCount: project.episodeCount,
                    totalCost: project.totalCost,
                    timestamp: new Date().toISOString()
                };
                
                const dataStr = JSON.stringify(projectData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = 'fence_project_' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.json';
                link.click();
                
                alert('Проект сохранен как JSON файл!');
            } catch (error) {
                console.error('Ошибка при сохранении JSON:', error);
                alert('Ошибка при сохранении проекта: ' + error.message);
            }
        }
        
        // Функция для отрисовки фона на canvas
        function drawBackgroundToCanvas(ctx, width, height) {
            if (userBackgroundImage && userBackgroundImage.complete) {
                ctx.drawImage(userBackgroundImage, 0, 0, width, height);
            } else if (nightBackgroundImage && nightBackgroundImage.complete) {
                ctx.drawImage(nightBackgroundImage, 0, 0, width, height);
            } else if (dayBackgroundImage && dayBackgroundImage.complete) {
                ctx.drawImage(dayBackgroundImage, 0, 0, width, height);
            }
        }
        
        // Функция для отрисовки элементов забора на canvas
        function drawFenceElementsToCanvas(ctx, width, height) {
            const groundY = height / 2;
            let currentX = 50;
            
            project.elements.forEach(element => {
                switch (element.type) {
                    case 'pole':
                        drawPoleToCanvas(ctx, currentX, groundY, element);
                        currentX += 50;
                        break;
                    case 'span':
                        drawSpanToCanvas(ctx, currentX, groundY, element);
                        currentX += (element.length || 250);
                        break;
                    case 'gate':
                        drawGateToCanvas(ctx, currentX, groundY, element);
                        currentX += (element.width || 400);
                        break;
                    case 'wicket':
                        drawWicketToCanvas(ctx, currentX, groundY, element);
                        currentX += (element.width || 100);
                        break;
                    case 'space':
                        currentX += (element.width || 100);
                        break;
                }
            });
        }
        
        // Функция для отрисовки столба на canvas
        function drawPoleToCanvas(ctx, x, y, element) {
            const height = (element.height || 8) * 20;
            const width = 50;
            
            // Рисуем блоки столба
            for (let i = 0; i < (element.height || 8); i++) {
                const blockY = y - (i * 20);
                ctx.fillStyle = '#666';
                ctx.fillRect(x, blockY, width, 20);
                
                // Рисуем текстуру блока (упрощенно)
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, blockY, width, 20);
            }
            
            // Рисуем крышку
            ctx.fillStyle = '#777';
            ctx.fillRect(x, y - height, width, 5);
        }
        
        // Функция для отрисовки пролета на canvas
        function drawSpanToCanvas(ctx, x, y, element) {
            const width = element.length || 250;
            const height = (element.rows || 1) * 20;
            const rightPoleHeight = (element.rightPoleHeight || 8) * 20;
            
            // Рисуем блоки пролета
            for (let row = 0; row < (element.rows || 1); row++) {
                for (let col = 0; col < Math.floor(width / 50); col++) {
                    const blockX = x + (col * 50);
                    const blockY = y - (row * 20);
                    ctx.fillStyle = '#666';
                    ctx.fillRect(blockX, blockY, 50, 20);
                    
                    // Рисуем текстуру блока
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(blockX, blockY, 50, 20);
                }
            }
            
            // Рисуем крышку
            ctx.fillStyle = '#777';
            ctx.fillRect(x, y - height, width, 5);
        }
        
        // Функция для отрисовки ворот на canvas
        function drawGateToCanvas(ctx, x, y, element) {
            const width = element.width || 400;
            const height = 160;
            
            // Рисуем заполнение ворот
            ctx.fillStyle = '#555';
            ctx.fillRect(x, y - height, width, height);
            
            // Рисуем рамку
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y - height, width, height);
        }
        
        // Функция для отрисовки калитки на canvas
        function drawWicketToCanvas(ctx, x, y, element) {
            const width = element.width || 100;
            const height = 160;
            
            // Рисуем заполнение калитки
            ctx.fillStyle = '#555';
            ctx.fillRect(x, y - height, width, height);
            
            // Рисуем рамку
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y - height, width, height);
        }
        
        // Функция для отрисовки водяных знаков на canvas
        function drawWatermarksToCanvas(ctx, width, height) {
            // Рисуем текст plitochka.by
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('plitochka.by', width - 20, 40);
            
            // Рисуем логотип (упрощенно как прямоугольник)
            ctx.fillStyle = 'rgba(255, 165, 0, 0.8)';
            ctx.fillRect(20, height - 80, 60, 60);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('LOGO', 50, height - 45);
        }
        
        // Функция для добавления водяных знаков
        function addWatermarks() {
            // Удаляем существующие водяные знаки
            removeWatermarks();
            
            // Создаем водяной знак plitochka.by
            const watermark1 = document.createElement('div');
            watermark1.id = 'watermark1';
            watermark1.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                color: rgba(255, 255, 255, 0.7);
                font-family: Arial, sans-serif;
                font-size: 16px;
                font-weight: bold;
                text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
                z-index: 1000;
                pointer-events: none;
            `;
            watermark1.textContent = 'plitochka.by';
            document.body.appendChild(watermark1);
            
            // Создаем логотип
            const logo = document.createElement('div');
            logo.id = 'watermarkLogo';
            logo.style.cssText = `
                position: absolute;
                bottom: 20px;
                left: 20px;
                width: 60px;
                height: 60px;
                background-image: url('filesfromPLprogramm/top/McAfee WebAdvisor/images/download_scan/logoPlotochkaRemove.png');
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                z-index: 1000;
                pointer-events: none;
                opacity: 0.8;
            `;
            document.body.appendChild(logo);
        }
        
        // Функция для добавления постоянных водяных знаков по всему полотну
        function addPermanentWatermarks() {
            // Удаляем существующие водяные знаки
            removeWatermarks();
            
            // Создаем контейнер для водяных знаков только на полотне забора
            const watermarkContainer = document.createElement('div');
            watermarkContainer.id = 'watermarkContainer';
            watermarkContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1000;
                overflow: hidden;
            `;
            
            // Добавляем контейнер только в полотно с забором
            const fenceViewport = document.getElementById('fenceViewport');
            if (fenceViewport) {
                // Добавляем водяные знаки только в полотно с забором
                fenceViewport.appendChild(watermarkContainer);
                console.log('Водяные знаки добавлены в полотно с забором (fenceViewport)');
            } else {
                // Fallback на main-canvas если fenceViewport не найден
                const mainCanvas = document.querySelector('.main-canvas');
                if (mainCanvas) {
                    mainCanvas.appendChild(watermarkContainer);
                    console.log('Водяные знаки добавлены в main-canvas');
                } else {
                    console.warn('Не найден контейнер для водяных знаков');
                    return; // Не добавляем водяные знаки если нет подходящего контейнера
                }
            }
            
            // Создаем классические водяные знаки для защиты цифрового изображения
            const diagonalAngle = -45; // Угол наклона 45 градусов
            const tileWidth = 300; // Ширина плитки
            const tileHeight = 200; // Высота плитки
            const logoSize = 24; // Размер логотипа
            const fontSize = 20; // Размер шрифта
            const offsetX = 150; // Смещение по X для создания шахматного узора
            const offsetY = 100; // Смещение по Y для создания шахматного узора
            
            // Получаем размеры только полотна с забором
            let containerWidth, containerHeight;
            
            if (fenceViewport) {
                // Используем fenceViewport (полотно с забором)
                containerWidth = fenceViewport.offsetWidth;
                containerHeight = fenceViewport.offsetHeight;
            } else {
                // Fallback на main-canvas если fenceViewport не найден
                const mainCanvas = document.querySelector('.main-canvas');
                if (mainCanvas) {
                    containerWidth = mainCanvas.offsetWidth;
                    containerHeight = mainCanvas.offsetHeight;
                } else {
                    // Последний fallback - минимальные размеры
                    containerWidth = 800;
                    containerHeight = 600;
                }
            }
            
            // Вычисляем количество плиток для полного покрытия с учетом смещения
            const tilesX = Math.ceil((containerWidth + tileWidth) / tileWidth) + 2;
            const tilesY = Math.ceil((containerHeight + tileHeight) / tileHeight) + 2;
            
            // Создаем классический узор с углом и смещением
            for (let row = -2; row < tilesY; row++) {
                for (let col = -2; col < tilesX; col++) {
                    const watermark = document.createElement('div');
                    watermark.className = 'watermark-tile';
                    
                    // Классическое смещение для создания шахматного узора
                    const isEvenRow = row % 2 === 0;
                    const isEvenCol = col % 2 === 0;
                    
                    // Позиционируем плитку с классическим смещением
                    let x = col * tileWidth;
                    let y = row * tileHeight;
                    
                    // Применяем смещение для создания классического узора
                    if (isEvenRow) {
                        x += offsetX;
                    }
                    if (isEvenCol) {
                        y += offsetY;
                    }
                    
                    // Дополнительное смещение для более сложного узора
                    if ((row + col) % 3 === 0) {
                        x += tileWidth * 0.3;
                        y += tileHeight * 0.2;
                    }
                    
                    watermark.style.cssText = `
                        position: absolute;
                        left: ${x}px;
                        top: ${y}px;
                        width: ${tileWidth}px;
                        height: ${tileHeight}px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: rgba(255, 255, 255, 0.08);
                        font-family: Arial, sans-serif;
                        font-size: ${fontSize}px;
                        font-weight: bold;
                        transform: rotate(${diagonalAngle}deg);
                        user-select: none;
                        pointer-events: none;
                        white-space: nowrap;
                        overflow: hidden;
                        opacity: 0.6;
                    `;
                    
                    // Создаем содержимое плитки (текст остается под углом 45 градусов)
                    const tileContent = document.createElement('div');
                    tileContent.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
                    `;
                    
                    // Создаем логотип
                    const logo = document.createElement('div');
                    logo.style.cssText = `
                        width: ${logoSize}px;
                        height: ${logoSize}px;
                        background-image: url('filesfromPLprogramm/top/McAfee WebAdvisor/images/download_scan/logoPlotochkaRemove.png');
                        background-size: contain;
                        background-repeat: no-repeat;
                        background-position: center;
                        opacity: 0.7;
                        flex-shrink: 0;
                        filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.3));
                    `;
                    
                    // Создаем текст
                    const text = document.createElement('span');
                    text.textContent = 'plitochka.by';
                    text.style.cssText = `
                        flex-shrink: 0;
                        letter-spacing: 1px;
                    `;
                    
                    tileContent.appendChild(logo);
                    tileContent.appendChild(text);
                    watermark.appendChild(tileContent);
                    watermarkContainer.appendChild(watermark);
                }
            }
        }
        

        // Функция для удаления временных водяных знаков (только для сохранения)
        function removeWatermarks() {
            const watermark1 = document.getElementById('watermark1');
            const logo = document.getElementById('watermarkLogo');
            
            if (watermark1) watermark1.remove();
            if (logo) logo.remove();
            // НЕ удаляем watermarkContainer - постоянные водяные знаки остаются
        }
        
        function clearProject() {
            if (confirm('Вы уверены, что хотите очистить проект?')) {
                project = {
                    elements: [],
                    totalLength: 0,
                    poleCount: 0,
                    panelCount: 0,
                    wicketCount: 0,
                    gateCount: 0,
                    spaceCount: 0,
                    episodeCount: 0,
                    totalCost: 0
                };
                
                // Сбрасываем фоновое изображение
                customBackgroundImage = null;
                userBackgroundImage = null;
                
                // Возвращаем прозрачность линии земли к 50%
                updateGroundLineOpacity(false);
                
                updateInfo();
                renderFenceElements();
                drawScene(); // Перерисовываем сцену без фона
                
                console.log('Проект очищен, прозрачность линии земли возвращена к 50%');
            }
        }
        
        // Тестовая функция для проверки расчета
        function testCalculation() {
            console.log('=== ТЕСТ РАСЧЕТА ===');
            console.log('project:', project);
            console.log('project.elements:', project.elements);
            console.log('project.elements.length:', project.elements ? project.elements.length : 'undefined');
            
            if (project.elements && project.elements.length > 0) {
                console.log('Первый элемент:', project.elements[0]);
            }
            
            // Принудительно вызываем расчет
            try {
                calculateProject();
            } catch (error) {
                console.error('Ошибка в calculateProject:', error);
                alert('Ошибка в расчете: ' + error.message);
            }
            
            // Тест модального окна с фиктивными данными
            console.log('Тестируем модальное окно...');
            showCalculationModal({
                totalPoles: 5,
                totalSpans: 4,
                totalGates: 1,
                totalWickets: 1,
                totalBlocks: 50,
                totalCaps: 10,
                totalLength: '12.5'
            });
        }
        
        // Функция для расчета проекта
        function calculateProject() {
            console.log('calculateProject вызвана');
            
            // Берем данные из нижнего меню
            const totalPoles = parseInt(document.getElementById('poleCount').textContent) || 0;
            const totalSpans = parseInt(document.getElementById('panelCount').textContent) || 0;
            const totalGates = parseInt(document.getElementById('gateCount').textContent) || 0;
            const totalWickets = parseInt(document.getElementById('wicketCount').textContent) || 0;
            const totalBlocks = parseInt(document.getElementById('blockCount').textContent) || 0;
            const totalCaps = parseInt(document.getElementById('capCount').textContent) || 0;
            const totalLength = getRulerTotalLength();
            
            console.log('Данные из нижнего меню:', {
                totalPoles,
                totalSpans,
                totalGates,
                totalWickets,
                totalBlocks,
                totalCaps,
                totalLength
            });
            
            // Проверяем, есть ли элементы
            if (totalPoles === 0 && totalSpans === 0 && totalGates === 0 && totalWickets === 0) {
                alert('Нет элементов для расчета. Добавьте столбы, пролеты, ворота или калитки.');
                return;
            }
            
            // Создаем модальное окно с результатами
            showCalculationModal({
                totalPoles,
                totalSpans,
                totalGates,
                totalWickets,
                totalBlocks,
                totalCaps,
                totalLength: totalLength.toFixed(1)
            });
        }
        
        // Функция для показа модального окна с расчетами
        function showCalculationModal(data) {
            console.log('showCalculationModal вызвана с данными:', data);
            
            // Создаем модальное окно
            const modal = document.createElement('div');
            modal.id = 'calculationModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: 'Helvetica Neue', Arial, sans-serif;
            `;
            
            // Создаем контент модального окна
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                max-width: 600px;
                min-height: 700px;
                margin: 40px auto;
                padding: 40px;
                background: #fff;
                border: 20px solid #3f3f3f;
                border-radius: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.05);
                color: #333;
                display: flex;
                flex-direction: column;
                max-height: 90vh;
                overflow-y: auto;
            `;
            
            // Формируем текст для Telegram
            const tgText = encodeURIComponent(
                `Введённые данные:\n` +
                `Общая длина забора: ${data.totalLength} м\n` +
                `Столбы: ${data.totalPoles} шт.\n` +
                `Пролеты: ${data.totalSpans} шт.\n` +
                `Ворота: ${data.totalGates} шт.\n` +
                `Калитки: ${data.totalWickets} шт.\n\n` +
                `Результат расчёта:\n` +
                `Количество столбов: ${data.totalPoles}\n` +
                `Количество блоков: ${data.totalBlocks}\n` +
                `Количество крышек: ${data.totalCaps}`
            );
            
            modalContent.innerHTML = `
                <div style="position: absolute; top: 5px; right: 5px; font-size: 6px; color: #ccc; font-family: monospace; z-index: 1000;">plitochka.by</div>
                <h3 style="font-size: 12px; color: #666; margin-bottom: 20px;">Введённые данные:</h3>
                <ul style="font-size: 12px; margin-bottom: 30px;">
                    <li>Общая длина забора: <b>${data.totalLength} м</b></li>
                    <li>Столбы: <b>${data.totalPoles} шт.</b></li>
                    <li>Пролеты: <b>${data.totalSpans} шт.</b></li>
                    <li>Ворота: <b>${data.totalGates} шт.</b></li>
                    <li>Калитки: <b>${data.totalWickets} шт.</b></li>
                </ul>
                
                <h3 style="font-size: 24px; color: #333; margin-left: 50px; margin-bottom: 20px;">Результат расчёта:</h3>
                <div style="font-size:20px;font-weight:700;margin-bottom:10px;margin-left:30px;">Количество столбов: <b>${data.totalPoles}</b></div>
                <div style="font-size:17px;font-weight:700;margin-bottom:8px;margin-left:30px;">Необходимое количество материала:</div>
                <ul style="margin-left:30px; margin-bottom: 30px;">
                    <li>Количество блоков: <b>${data.totalBlocks}</b></li>
                    <li>Количество крышек: <b>${data.totalCaps}</b></li>
                </ul>
                
                <div style="text-align: center; margin: 30px 0;">
                    <button id="copy-text-btn" style="
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        padding: 8px 16px;
                        background: transparent;
                        color: #3f3f3f;
                        border: 1px solid #3f3f3f;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 700;
                        transition: all 0.2s ease;
                    ">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM19 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H19C20.1 23 21 22.1 21 21V7C21 5.9 20.1 5 19 5ZM19 21H8V7H19V21Z" fill="currentColor"/>
                        </svg>
                        Скопировать текст расчета
                    </button>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <a id="quiz-tg-link" href="https://t.me/plitochkaby_manager?text=${tgText}" target="_blank" style="
                        display: inline-flex;
                        align-items: center;
                        gap: 12px;
                        padding: 16px 24px;
                        background: linear-gradient(135deg, #1E88C3 0%, #1565C0 100%);
                        color: #ffffff;
                        text-decoration: none;
                        font-size: 18px;
                        font-weight: 800;
                        border-radius: 8px;
                        box-shadow: 0 4px 16px rgba(34, 158, 217, 0.3);
                        transition: all 0.3s ease;
                        overflow: hidden;
                        position: relative;
                        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                    ">
                        <img src="https://static.tildacdn.biz/tild3863-3239-4162-a466-366433363165/socials-3.svg" alt="Telegram" style="width: 24px; height: 24px;">
                        <span>Отправить расчет менеджеру</span>
                    </a>
                </div>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button id="close-modal-btn" style="
                        padding: 12px 24px;
                        background: #3f3f3f;
                        color: #fff;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 16px;
                        font-weight: 700;
                        transition: background 0.2s ease;
                    ">Закрыть</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            console.log('Модальное окно добавлено в DOM');
            
            // Обработчики событий
            document.getElementById('close-modal-btn').onclick = function() {
                document.body.removeChild(modal);
            };
            
            // Закрытие по клику вне модального окна
            modal.onclick = function(e) {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
            
            // Обработчик для копирования текста
            document.getElementById('copy-text-btn').onclick = function() {
                const textToCopy = `Введённые данные:
Общая длина забора: ${data.totalLength} м
Столбы: ${data.totalPoles} шт.
Пролеты: ${data.totalSpans} шт.
Ворота: ${data.totalGates} шт.
Калитки: ${data.totalWickets} шт.

Результат расчёта:
Количество столбов: ${data.totalPoles}
Количество блоков: ${data.totalBlocks}
Количество крышек: ${data.totalCaps}`;
                
                // Пытаемся скопировать в буфер обмена
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        this.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 16.17L4.83 12L3.41 13.41L9 19L21 7L19.59 5.59L9 16.17Z" fill="currentColor"/></svg>Скопировано!';
                        this.style.background = '#4CAF50';
                        this.style.color = '#fff';
                        this.style.borderColor = '#4CAF50';
                    }).catch(() => {
                        fallbackCopyTextToClipboard(textToCopy, this);
                    });
                } else {
                    fallbackCopyTextToClipboard(textToCopy, this);
                }
            };
            
            // Fallback функция для копирования
            function fallbackCopyTextToClipboard(text, button) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    button.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 16.17L4.83 12L3.41 13.41L9 19L21 7L19.59 5.59L9 16.17Z" fill="currentColor"/></svg>Скопировано!';
                    button.style.background = '#4CAF50';
                    button.style.color = '#fff';
                    button.style.borderColor = '#4CAF50';
                } catch (err) {
                    console.error('Ошибка копирования:', err);
                    button.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12S6.48 22 12 22 22 17.52 22 12 17.52 2 12 2ZM13 17H11V15H13V17ZM13 13H11V7H13V13Z" fill="currentColor"/></svg>Ошибка копирования';
                    button.style.background = '#f44336';
                    button.style.color = '#fff';
                    button.style.borderColor = '#f44336';
                }
                
                document.body.removeChild(textArea);
            }
        }
        
        function resetProject() {
            if (confirm('Вы уверены, что хотите сбросить проект к начальным настройкам?')) {
                const lengthEl = document.getElementById('length');
                const poleDistanceEl = document.getElementById('poleDistance');
                const angleEl = document.getElementById('angle');
                
                if (lengthEl) lengthEl.value = 12;
                if (poleDistanceEl) poleDistanceEl.value = 2.5;
                if (angleEl) angleEl.value = 0;
                clearProject();
            }
        }
        
        function closeProject() {
            if (confirm('Вы уверены, что хотите закрыть проект?')) {
                window.close();
            }
        }
        
        // Функции редактирования столба
        function openPoleEditor(poleElement, poleData) {
            selectedPole = poleData;
            selectedPoleElement = poleElement;
            
            const sidebar = document.getElementById('poleEditorSidebar');
            const heightInput = document.getElementById('poleHeightEditor');
            
            // Устанавливаем текущую высоту столба
            const currentHeight = poleData.height || 8;
            heightInput.value = currentHeight;
            
            // Показываем сайдбар
            sidebar.style.display = 'block';
            
            console.log('Открыт редактор столба:', poleData);
        }
        
        function closePoleEditor() {
            const sidebar = document.getElementById('poleEditorSidebar');
            sidebar.style.display = 'none';
            
            // Убираем выделение со столба
            if (selectedPoleElement) {
                selectedPoleElement.classList.remove('selected');
            }
            
            selectedPole = null;
            selectedPoleElement = null;
            
            console.log('Редактор столба закрыт');
        }
        
        function changePoleHeight(delta) {
            if (!selectedPole) return;
            
            const heightInput = document.getElementById('poleHeightEditor');
            const currentHeight = parseInt(heightInput.value) || 8;
            const newHeight = Math.max(1, Math.min(20, currentHeight + delta)); // Ограничиваем от 1 до 20 блоков
            
            heightInput.value = newHeight;
            selectedPole.height = newHeight;
            
            // НЕ очищаем текстуры - сохраняем существующие
            // Только добавляем новые текстуры для новых блоков, если высота увеличилась
            if (newHeight > currentHeight) {
                // Добавляем новые текстуры для новых блоков
                for (let i = currentHeight; i < newHeight; i++) {
                    let randomRow, randomCol;
                    let lastTexture = selectedPole.textures.length > 0 ? selectedPole.textures[selectedPole.textures.length - 1] : -1;
                    
                    do {
                        randomRow = Math.floor(Math.random() * 3);
                        randomCol = Math.floor(Math.random() * 3);
                    } while (randomRow * 3 + randomCol === lastTexture);
                    
                    const newTexture = randomRow * 3 + randomCol;
                    selectedPole.textures.push(newTexture);
                    console.log(`Добавлена новая текстура для блока ${i + 1}:`, newTexture);
                }
            } else if (newHeight < currentHeight) {
                // Убираем лишние текстуры, если высота уменьшилась
                selectedPole.textures = selectedPole.textures.slice(0, newHeight);
            }
            
            // Находим элемент слева от редактируемого столба и обновляем его высоту
            const poleIndex = project.elements.findIndex(el => el.id === selectedPole.id);
            if (poleIndex > 0) {
                const leftElement = project.elements[poleIndex - 1];
                if (leftElement && (leftElement.type === 'wicket' || leftElement.type === 'gate' || leftElement.type === 'panel')) {
                    // Обновляем высоту элемента слева от столба
                    leftElement.height = newHeight;
                    console.log('Обновлена высота элемента слева от столба:', leftElement.type, 'на', newHeight);
                }
            }
            
            // Проверяем, нужно ли применить ко всем столбам
            const applyToAll = document.getElementById('applyToAllPoles').checked;
            if (applyToAll) {
                project.elements.forEach((element, index) => {
                    if (element.type === 'pole') {
                        const oldHeight = element.height || 8;
                        element.height = newHeight;
                        
                        // Аналогично обрабатываем текстуры для всех столбов
                        if (newHeight > oldHeight) {
                            for (let i = oldHeight; i < newHeight; i++) {
                                let randomRow, randomCol;
                                let lastTexture = element.textures.length > 0 ? element.textures[element.textures.length - 1] : -1;
                                
                                do {
                                    randomRow = Math.floor(Math.random() * 3);
                                    randomCol = Math.floor(Math.random() * 3);
                                } while (randomRow * 3 + randomCol === lastTexture);
                                
                                const newTexture = randomRow * 3 + randomCol;
                                element.textures.push(newTexture);
                            }
                        } else if (newHeight < oldHeight) {
                            element.textures = element.textures.slice(0, newHeight);
                        }
                        
                        // Также обновляем высоту элемента слева от каждого столба
                        if (index > 0) {
                            const leftElement = project.elements[index - 1];
                            if (leftElement && (leftElement.type === 'wicket' || leftElement.type === 'gate' || leftElement.type === 'panel')) {
                                leftElement.height = newHeight;
                                console.log('Обновлена высота элемента слева от столба', index, ':', leftElement.type, 'на', newHeight);
                            }
                        }
                    }
                });
            }
            
            // Сразу применяем изменения - перерисовываем элементы
            renderFenceElements();
            
            console.log('Изменена высота столба на:', newHeight, 'Текстуры сохранены и дополнены');

            // Если флажок стоит, закрепляем глобально
            if (applyToAll) pinnedPoleHeight = newHeight;
        }

        // Перемещение выбранного столба стрелками влево/вправо (шаг 0.5м = 50px)
        const POLE_MOVE_STEP_PX = 50;

        function isPanelElement(el) {
            return el && el.type === 'panel';
        }

        // Элементы, которые ведут себя как пролёты по ширине
        function isSpanLikeElement(el) {
            return el && (el.type === 'panel' || el.type === 'gate' || el.type === 'wicket' || el.type === 'space');
        }

        function getSpanLikeWidthPx(el) {
            if (!el) return 0;
            if (el.type === 'panel') return (typeof el.length === 'number') ? el.length : 0;
            if (el.type === 'gate' || el.type === 'wicket' || el.type === 'space') return (typeof el.width === 'number') ? el.width : 0;
            return 0;
        }

        function setSpanLikeWidthPx(el, widthPx) {
            if (!el) return;
            if (el.type === 'panel') {
                el.length = widthPx;
                el.realLength = widthPx / 100;
            } else if (el.type === 'gate' || el.type === 'wicket' || el.type === 'space') {
                el.width = widthPx;
            }
        }

        function adjustSpanLikeWidth(el, deltaPx) {
            if (!isSpanLikeElement(el)) return false;
            const current = getSpanLikeWidthPx(el);
            const next = Math.max(0, current + deltaPx);
            if (deltaPx < 0 && current <= 0) return false; // уже 0.0м
            setSpanLikeWidthPx(el, next);
            return true;
        }

        function isRightmostPole(index) {
            return index >= project.elements.length - 1;
        }

        // Оставляем обёртку для совместимости со старым вызовом
        function adjustPanelLength(panel, deltaPx) {
            return adjustSpanLikeWidth(panel, deltaPx);
        }

        function moveSelectedPole(direction) {
            if (!selectedPole) return;
            const idx = project.elements.findIndex(el => el.id === selectedPole.id);
            if (idx === -1) return;

            const leftEl = project.elements[idx - 1];
            const rightEl = project.elements[idx + 1];

            if (isRightmostPole(idx)) {
                // Крайний правый столб: вправо увеличиваем левый и общую длину; влево уменьшаем левый и уменьшаем общую длину
                if (!isSpanLikeElement(leftEl)) return;
                if (direction > 0) {
                    adjustSpanLikeWidth(leftEl, POLE_MOVE_STEP_PX);
                } else if (direction < 0) {
                    const couldDec = adjustSpanLikeWidth(leftEl, -POLE_MOVE_STEP_PX);
                    if (!couldDec) return; // упор
                }
            } else {
                // Внутренний столб: строго по требованию
                if (!isSpanLikeElement(leftEl) || !isSpanLikeElement(rightEl)) return;
                const rightLen = getSpanLikeWidthPx(rightEl);
                const leftLen = getSpanLikeWidthPx(leftEl);

                if (direction < 0) {
                    // Влево: уменьшаем ЛЕВЫЙ, увеличиваем ПРАВЫЙ;
                    // Особый случай: если слева 0.0м (сдвоенные столбы) — раздвигаем, создав слева 0.5м, ничего справа не меняем
                    if (leftLen === 0) {
                        adjustSpanLikeWidth(leftEl, POLE_MOVE_STEP_PX);
                        return;
                    }
                    if (leftLen > POLE_MOVE_STEP_PX) {
                        const ok = adjustSpanLikeWidth(leftEl, -POLE_MOVE_STEP_PX);
                        if (!ok) return;
                        adjustSpanLikeWidth(rightEl, POLE_MOVE_STEP_PX);
                    } else if (leftLen === POLE_MOVE_STEP_PX) {
                        // сводим зазор к 0.0м и компенсируем справа +0.5м (длина сохраняется)
                        const ok = adjustSpanLikeWidth(leftEl, -POLE_MOVE_STEP_PX);
                        if (!ok) return;
                        adjustSpanLikeWidth(rightEl, POLE_MOVE_STEP_PX);
                    }
                } else if (direction > 0) {
                    // Вправо: уменьшаем ПРАВЫЙ, увеличиваем ЛЕВЫЙ;
                    // Особый случай: если справа 0.0м (сдвоенные столбы) — раздвигаем, создав справа 0.5м
                    if (rightLen === 0) {
                        adjustSpanLikeWidth(rightEl, POLE_MOVE_STEP_PX);
                        return;
                    }
                    if (rightLen > POLE_MOVE_STEP_PX) {
                        const ok = adjustSpanLikeWidth(rightEl, -POLE_MOVE_STEP_PX);
                        if (!ok) return;
                        adjustSpanLikeWidth(leftEl, POLE_MOVE_STEP_PX);
                    } else if (rightLen === POLE_MOVE_STEP_PX) {
                        // сводим зазор к 0.0м и компенсируем слева +0.5м (длина сохраняется)
                        const ok = adjustSpanLikeWidth(rightEl, -POLE_MOVE_STEP_PX);
                        if (!ok) return;
                        adjustSpanLikeWidth(leftEl, POLE_MOVE_STEP_PX);
                    }
                }
            }

            // Применяем изменения немедленно
            updateInfo();
            renderFenceElements();
        }

        // Обработчик нажатий клавиш для перемещения выбранного столба
        window.addEventListener('keydown', (event) => {
            // Удаление выбранного элемента клавишей Delete
            if (event.key === 'Delete') {
                event.preventDefault();
                deleteSelectedElement();
                return;
            }

            if (selectedPole) {
                if (event.key === 'ArrowLeft') {
                    event.preventDefault();
                    moveSelectedPole(-1);
                } else if (event.key === 'ArrowRight') {
                    event.preventDefault();
                    moveSelectedPole(1);
                }
            }
        });

        function deleteSelectedElement() {
            // Удаляем выбранный столб/пролёт/ворота/калитку/проём
            let idToDelete = null;
            let type = null;
            if (selectedPole) { idToDelete = selectedPole.id; type = 'pole'; }
            else if (selectedSpan) { idToDelete = selectedSpan.id; type = 'panel'; }
            else if (selectedGate) { idToDelete = selectedGate.id; type = 'gate'; }
            else if (selectedWicket) { idToDelete = selectedWicket.id; type = 'wicket'; }
            else if (selectedSpace) { idToDelete = selectedSpace.id; type = 'space'; }
            if (idToDelete == null) return;

            // Если удаляем пролёт/ворота/калитку — удалим привязанный правый автогенерируемый столб
            if (type === 'panel' || type === 'gate' || type === 'wicket') {
                const idx = project.elements.findIndex(el => el.id === idToDelete);
                if (idx !== -1 && idx < project.elements.length - 1) {
                    const rightEl = project.elements[idx + 1];
                    if (rightEl && rightEl.type === 'pole' && rightEl.isAutoGenerated && rightEl.linkedTo === idToDelete) {
                        project.elements.splice(idx + 1, 1);
                        project.poleCount = Math.max(0, project.poleCount - 1);
                    }
                }
            }

            // Удаляем сам элемент
            const before = project.elements.length;
            project.elements = project.elements.filter(el => el.id !== idToDelete);
            const after = project.elements.length;
            if (before !== after) {
                if (type === 'pole') project.poleCount = Math.max(0, project.poleCount - 1);
                if (type === 'panel') project.panelCount = Math.max(0, project.panelCount - 1);
                if (type === 'gate') project.gateCount = Math.max(0, project.gateCount - 1);
                if (type === 'wicket') project.wicketCount = Math.max(0, project.wicketCount - 1);
                if (type === 'space') project.spaceCount = Math.max(0, project.spaceCount - 1);
            }

            // Сброс выбора и перерисовка
            selectedPole = selectedSpan = selectedGate = selectedWicket = selectedSpace = null;
            selectedPoleElement = selectedSpanElement = selectedGateElement = selectedWicketElement = selectedSpaceElement = null;
            renderFenceElements();
            updateInfo();
        }
        
        function toggleApplyToAllPoles() {
            const checkbox = document.getElementById('applyToAllPoles');
            console.log('Применить ко всем столбам:', checkbox.checked);
        }
        
        function toggleApplyToAllSpans() {
            const checkbox = document.getElementById('applyToAllSpans');
            console.log('Применить ко всем пролётам:', checkbox.checked);
        }
        
        // Функции изменения параметров пролётов
        function changeSpanWidth(delta) {
            if (!selectedSpan) return;
            
            const widthInput = document.getElementById('spanWidthEditor');
            const currentWidth = parseFloat(widthInput.value) || 2.5;
            const newWidth = Math.max(0.0, Math.min(10.0, currentWidth + delta));
            
            widthInput.value = newWidth;
            selectedSpan.length = Math.max(0, Math.round(newWidth * 100));
            
            // Обрабатываем изменение количества блоков как добавление/удаление справа
            const oldBlockCount = Math.floor((currentWidth * 100) / 50);
            const newBlockCount = Math.floor((selectedSpan.length) / 50);
            const rowsCount = selectedSpan.rows || 1;

            console.log(`Изменение ширины: ${currentWidth}м -> ${newWidth}м, блоки: ${oldBlockCount} -> ${newBlockCount}`);

            // Гарантируем матрицу текстур
            ensurePanelTextures(selectedSpan, rowsCount, oldBlockCount);
            ensurePanelPeakTextures(selectedSpan, oldBlockCount);

            if (newBlockCount > oldBlockCount) {
                const toAdd = newBlockCount - oldBlockCount;
                for (let r = 0; r < rowsCount; r++) {
                    let lastTex = selectedSpan.textures[r].length > 0 ? selectedSpan.textures[r][selectedSpan.textures[r].length - 1] : -1;
                    for (let i = 0; i < toAdd; i++) {
                        const tex = generateRandomBlockTexture(lastTex);
                        selectedSpan.textures[r].push(tex);
                        lastTex = tex;
                    }
                }
                for (let i = 0; i < toAdd; i++) {
                    selectedSpan.peakTextures.push(Math.floor(Math.random() * 3));
                }
            } else if (newBlockCount < oldBlockCount) {
                const toRemove = oldBlockCount - newBlockCount;
                for (let r = 0; r < rowsCount; r++) {
                    selectedSpan.textures[r] = selectedSpan.textures[r].slice(0, newBlockCount);
                }
                selectedSpan.peakTextures = selectedSpan.peakTextures.slice(0, newBlockCount);
            }
            
            // Проверяем, нужно ли применить ко всем пролётам
            const applyToAll = document.getElementById('applyWidthToAllSpans').checked;
            if (applyToAll) {
                project.elements.forEach((element, index) => {
                    if (element.type === 'panel') {
                        const oldLengthLocal = element.length || 250;
                        const oldBlocks = Math.floor(oldLengthLocal / 50);
                        const newBlocks = Math.floor(newWidth * 100 / 50);
                        const rowsLocal = element.rows || 1;

                        ensurePanelTextures(element, rowsLocal, oldBlocks);
                        ensurePanelPeakTextures(element, oldBlocks);

                        if (newBlocks > oldBlocks) {
                            const addCount = newBlocks - oldBlocks;
                            for (let r = 0; r < rowsLocal; r++) {
                                let lastTex = element.textures[r].length > 0 ? element.textures[r][element.textures[r].length - 1] : -1;
                                for (let i = 0; i < addCount; i++) {
                                    const tex = generateRandomBlockTexture(lastTex);
                                    element.textures[r].push(tex);
                                    lastTex = tex;
                                }
                            }
                            for (let i = 0; i < addCount; i++) {
                                element.peakTextures.push(Math.floor(Math.random() * 3));
                            }
                        } else if (newBlocks < oldBlocks) {
                            const removeCount = oldBlocks - newBlocks;
                            for (let r = 0; r < rowsLocal; r++) {
                                element.textures[r] = element.textures[r].slice(0, newBlocks);
                            }
                            element.peakTextures = element.peakTextures.slice(0, newBlocks);
                        }

                        element.length = newWidth * 100;
                        console.log('Обновлена ширина пролёта', index, ':', element.type, 'на', newWidth, 'блоков:', newBlocks);
                    }
                });
            }
            
            // Сразу применяем изменения
            renderFenceElements();
            console.log('Изменена ширина пролёта на:', newWidth, 'блоков:', newBlockCount);

            // Если флажок стоит, закрепляем глобально
            if (applyToAll) pinnedSpanWidthM = newWidth;
        }
        

        
        function changeSpanRows(delta) {
            if (!selectedSpan) return;
            
            const rowsInput = document.getElementById('spanRowsEditor');
            const currentRows = parseInt(rowsInput.value) || 1;
            
            // Находим столб справа от пролёта для определения максимального количества рядов
            const spanIndex = project.elements.findIndex(el => el.id === selectedSpan.id);
            let maxRows = 8; // По умолчанию 8 рядов
            
            if (spanIndex < project.elements.length - 1) {
                const rightPole = project.elements[spanIndex + 1];
                if (rightPole && rightPole.type === 'pole') {
                    maxRows = rightPole.height || 8;
                }
            }
            
            const newRows = Math.max(1, Math.min(maxRows, currentRows + delta));
            
            rowsInput.value = newRows;
            
            const oldRows = selectedSpan.rows || 1;
            const blockCount = Math.floor((selectedSpan.length || 250) / 50);

            // Обеспечиваем матрицу на основе старых рядов
            ensurePanelTextures(selectedSpan, oldRows, blockCount);

            selectedSpan.rows = newRows;

            if (newRows > oldRows) {
                // Добавляем новые ряды сверху (логически выше), но для хранения просто расширяем массив
                for (let r = oldRows; r < newRows; r++) {
                    selectedSpan.textures[r] = [];
                    let lastTex = -1;
                    for (let c = 0; c < blockCount; c++) {
                        const tex = generateRandomBlockTexture(lastTex);
                        selectedSpan.textures[r].push(tex);
                        lastTex = tex;
                    }
                }
            } else if (newRows < oldRows) {
                selectedSpan.textures = selectedSpan.textures.slice(0, newRows);
            }
            
            // Проверяем, нужно ли применить ко всем пролётам
            const applyToAll = document.getElementById('applyRowsToAllSpans').checked;
            if (applyToAll) {
                project.elements.forEach((element, index) => {
                    if (element.type === 'panel') {
                        // Определяем максимальное количество рядов для каждого пролёта
                        let elementMaxRows = 8;
                        if (index < project.elements.length - 1) {
                            const rightPole = project.elements[index + 1];
                            if (rightPole && rightPole.type === 'pole') {
                                elementMaxRows = rightPole.height || 8;
                            }
                        }
                        
                        const oldRowsLocal = element.rows || 1;
                        const rowsTarget = Math.min(newRows, elementMaxRows);
                        const blockCountLocal = Math.floor((element.length || 250) / 50);

                        ensurePanelTextures(element, oldRowsLocal, blockCountLocal);

                        element.rows = rowsTarget;

                        if (rowsTarget > oldRowsLocal) {
                            for (let r = oldRowsLocal; r < rowsTarget; r++) {
                                element.textures[r] = [];
                                let lastTex = -1;
                                for (let c = 0; c < blockCountLocal; c++) {
                                    const tex = generateRandomBlockTexture(lastTex);
                                    element.textures[r].push(tex);
                                    lastTex = tex;
                                }
                            }
                        } else if (rowsTarget < oldRowsLocal) {
                            element.textures = element.textures.slice(0, rowsTarget);
                        }
                        
                        console.log('Обновлено количество рядов пролёта', index, ':', element.type, 'на', element.rows);
                    }
                });
            }
            
            // Сразу применяем изменения
            renderFenceElements();
            console.log('Изменено количество рядов пролёта на:', newRows, 'максимум:', maxRows);
        }
        
        // Функция для изменения цвета заполнения (только для пролётов)
        function changeFillColor(color) {
            globalFillColor = color;
            console.log('Изменен цвет заполнения на:', color);
            
            // Применяем новый цвет только к пролётам
            applyFillColorToSpansOnly(color);
        }
        
        // Функция для изменения цвета пролётов
        function changeSpanColor(color) {
            changeFillColor(color);
            updateColorButtonStates('span', color);
        }
        
        // Функция для изменения цвета блоков
        function changeBlockColor(color) {
            globalBlockColor = color;
            console.log('Изменен цвет блоков на:', color);
            
            // Применяем новый цвет ко всем блокам и крышкам
            applyBlockColorToAllElements(color);
            
            // Обновляем состояние кнопок
            updateBlockColorButtonStates(color);
        }
        
        // Функция для применения цвета блоков ко всем элементам
        function applyBlockColorToAllElements(color) {
            const allBlocks = document.querySelectorAll('.fence-block');
            const allPeaks = document.querySelectorAll('.fence-peak');
            
            allBlocks.forEach(block => {
                const currentBgPos = block.style.backgroundPosition;
                block.style.backgroundImage = `url("${getBlockTexturePath(color)}")`;
                block.style.backgroundPosition = currentBgPos; // Сохраняем позицию
            });
            
            allPeaks.forEach(peak => {
                const currentBgPos = peak.style.backgroundPosition;
                peak.style.backgroundImage = `url("${getPeakTexturePath(color)}")`;
                peak.style.backgroundPosition = currentBgPos; // Сохраняем позицию
            });
        }
        
        // Функция для обновления состояния кнопок цвета блоков
        function updateBlockColorButtonStates(selectedColor) {
            // Кнопки в секции пролетов
            const spanOnyxButton = document.getElementById('blockColorOnyx');
            const spanBlackMixButton = document.getElementById('blockColorBlackMix');
            
            // Кнопки в секции столбов
            const poleOnyxButton = document.getElementById('poleBlockColorOnyx');
            const poleBlackMixButton = document.getElementById('poleBlockColorBlackMix');
            
            // Сбрасываем стили всех кнопок в секции пролетов
            if (spanOnyxButton) {
                spanOnyxButton.style.border = '2px solid #444';
                spanOnyxButton.style.boxShadow = 'none';
            }
            if (spanBlackMixButton) {
                spanBlackMixButton.style.border = '2px solid #111';
                spanBlackMixButton.style.boxShadow = 'none';
            }
            
            // Сбрасываем стили всех кнопок в секции столбов
            if (poleOnyxButton) {
                poleOnyxButton.style.border = '2px solid #444';
                poleOnyxButton.style.boxShadow = 'none';
            }
            if (poleBlackMixButton) {
                poleBlackMixButton.style.border = '2px solid #111';
                poleBlackMixButton.style.boxShadow = 'none';
            }
            
            // Подсвечиваем выбранную кнопку в секции пролетов
            if (selectedColor === 'onyx' && spanOnyxButton) {
                spanOnyxButton.style.border = '2px solid #ff6600';
                spanOnyxButton.style.boxShadow = '0 0 8px rgba(255, 102, 0, 0.5)';
            } else if (selectedColor === 'black_mix' && spanBlackMixButton) {
                spanBlackMixButton.style.border = '2px solid #ff6600';
                spanBlackMixButton.style.boxShadow = '0 0 8px rgba(255, 102, 0, 0.5)';
            }
            
            // Подсвечиваем выбранную кнопку в секции столбов
            if (selectedColor === 'onyx' && poleOnyxButton) {
                poleOnyxButton.style.border = '2px solid #ff6600';
                poleOnyxButton.style.boxShadow = '0 0 8px rgba(255, 102, 0, 0.5)';
            } else if (selectedColor === 'black_mix' && poleBlackMixButton) {
                poleBlackMixButton.style.border = '2px solid #ff6600';
                poleBlackMixButton.style.boxShadow = '0 0 8px rgba(255, 102, 0, 0.5)';
            }
        }
        
        // Функция для изменения цвета калиток
        function changeWicketColor(color) {
            if (!selectedWicket) return;
            
            selectedWicket.fillColor = color;
            console.log('Изменен цвет калитки на:', color);
            
            // Применяем цвет к выбранной калитке
            applyWicketColor(selectedWicketElement, color);
            
            // Обновляем состояние кнопок
            updateColorButtonStates('wicket', color);
        }
        
        // Функция для изменения цвета ворот
        function changeGateColor(color) {
            if (!selectedGate) return;
            
            selectedGate.fillColor = color;
            console.log('Изменен цвет ворот на:', color);
            
            // Применяем цвет к выбранным воротам
            applyGateColor(selectedGateElement, color);
            
            // Обновляем состояние кнопок
            updateColorButtonStates('gate', color);
        }
        
        // Функция для изменения ширины калитки
        function changeWicketWidth(delta) {
            if (!selectedWicket) return;
            
            const widthInput = document.getElementById('wicketWidthEditor');
            const currentWidth = parseFloat(widthInput.value) || 1.0;
            const newWidth = Math.max(0.5, Math.min(2.0, currentWidth + delta));
            
            widthInput.value = newWidth;
            selectedWicket.width = newWidth * 100; // Сохраняем в пикселях
            
            console.log('Изменена ширина калитки на:', newWidth);
            
            // Сразу применяем изменения
            renderFenceElements();
        }

        // Функция изменения ширины проёма
        function changeSpaceWidth(delta) {
            if (!selectedSpace) return;
            const widthInput = document.getElementById('spaceWidthEditor');
            const currentWidth = parseFloat(widthInput.value) || 1.0;
            const newWidth = Math.max(0.5, Math.min(10.0, currentWidth + delta));
            widthInput.value = newWidth;
            selectedSpace.width = newWidth * 100;
            // Немедленно применяем изменения
            renderFenceElements();
        }
        
        // Функция для изменения ширины ворот
        function changeGateWidth(delta) {
            if (!selectedGate) return;
            
            const widthInput = document.getElementById('gateWidthEditor');
            const currentWidth = parseFloat(widthInput.value) || 4.0;
            const newWidth = Math.max(2.0, Math.min(6.0, currentWidth + delta));
            
            widthInput.value = newWidth;
            selectedGate.width = newWidth * 100; // Сохраняем в пикселях
            
            console.log('Изменена ширина ворот на:', newWidth);
            
            // Сразу применяем изменения
            renderFenceElements();
        }
        
        // Функция для применения цвета к элементу
        function applyColorToElement(element, color) {
            if (color === 'mokka') {
                element.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/mokka1.jpg")';
                element.style.backgroundSize = 'cover';
                element.style.backgroundPosition = 'center';
                element.style.backgroundRepeat = 'no-repeat';
            } else {
                element.style.backgroundImage = 'none';
                element.style.background = '#555'; /* Тёмно-серое заполнение по умолчанию */
            }
        }
        
        // Функция для применения цвета к калитке
        function applyWicketColor(element, color) {
            if (color === 'mokka') {
                element.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/mokka1.jpg")';
                element.style.backgroundSize = 'cover';
                element.style.backgroundPosition = 'center';
                element.style.backgroundRepeat = 'no-repeat';
            } else if (color === 'ranch') {
                element.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/ranCHo.png")';
                element.style.backgroundSize = '100% 100%'; /* Растягиваем по всей ширине и высоте калитки */
                element.style.backgroundRepeat = 'no-repeat';
                element.style.backgroundPosition = 'center';
                element.style.backgroundColor = 'transparent';
                element.style.mixBlendMode = 'multiply'; /* Белые участки становятся прозрачными, темные остаются */
                element.style.isolation = 'isolate'; /* Изолируем эффект смешивания */
            } else {
                element.style.backgroundImage = 'none';
                element.style.background = '#555'; /* Тёмно-серое заполнение по умолчанию */
            }
        }
        
        // Функция для применения цвета к воротам
        function applyGateColor(element, color) {
            if (color === 'mokka') {
                element.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/mokka1.jpg")';
                element.style.backgroundSize = 'cover';
                element.style.backgroundPosition = 'center';
                element.style.backgroundRepeat = 'no-repeat';
            } else if (color === 'ranch') {
                element.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/ranCHo.png")';
                element.style.backgroundSize = '100% 100%'; /* Растягиваем по всей ширине и высоте ворот */
                element.style.backgroundRepeat = 'no-repeat';
                element.style.backgroundPosition = 'center';
                element.style.backgroundColor = 'transparent';
                element.style.mixBlendMode = 'multiply'; /* Белые участки становятся прозрачными, темные остаются */
                element.style.isolation = 'isolate'; /* Изолируем эффект смешивания */
            } else {
                element.style.backgroundImage = 'none';
                element.style.background = '#555'; /* Тёмно-серое заполнение по умолчанию */
            }
        }
        
        // Функция для обновления состояния кнопок цветов
        function updateColorButtonStates(elementType, selectedColor) {
            const grayButton = document.getElementById(`${elementType}ColorGray`);
            const mokkaButton = document.getElementById(`${elementType}ColorMokka`);
            const ranchButton = document.getElementById(`${elementType}ColorRanch`);
            
            // Сбрасываем стили всех кнопок
            if (grayButton) {
                grayButton.style.border = '2px solid #333';
                grayButton.style.boxShadow = 'none';
            }
            if (mokkaButton) {
                mokkaButton.style.border = '2px solid #654321';
                mokkaButton.style.boxShadow = 'none';
            }
            if (ranchButton) {
                ranchButton.style.border = '2px solid #6B5B47';
                ranchButton.style.boxShadow = 'none';
            }
            
            // Подсвечиваем выбранную кнопку
            if (selectedColor === 'gray' && grayButton) {
                grayButton.style.border = '2px solid #ff6600';
                grayButton.style.boxShadow = '0 0 8px rgba(255, 102, 0, 0.5)';
            } else if (selectedColor === 'mokka' && mokkaButton) {
                mokkaButton.style.border = '2px solid #ff6600';
                mokkaButton.style.boxShadow = '0 0 8px rgba(255, 102, 0, 0.5)';
            } else if (selectedColor === 'ranch' && ranchButton) {
                ranchButton.style.border = '2px solid #ff6600';
                ranchButton.style.boxShadow = '0 0 8px rgba(255, 102, 0, 0.5)';
            }
        }
        
        // Применение цвета заполнения только к пролётам
        function applyFillColorToSpansOnly(color) {
            const elements = document.querySelectorAll('.fence-span');
            
            elements.forEach(element => {
                if (color === 'mokka') {
                    element.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/mokka1.jpg")';
                    element.style.backgroundSize = 'cover';
                    element.style.backgroundPosition = 'center';
                    element.style.backgroundRepeat = 'no-repeat';
                } else if (color === 'ranch') {
                    element.style.backgroundImage = 'url("filesfromPLprogramm/top/app.kalkulatorogrodzenia.pl/assets/new/panels/default/ranCHo.png")';
                    element.style.backgroundSize = '100% 100%'; /* Растягиваем по всей ширине и высоте пролета */
                    element.style.backgroundRepeat = 'no-repeat';
                    element.style.backgroundPosition = 'center';
                    element.style.backgroundColor = 'transparent';
                    element.style.mixBlendMode = 'multiply'; /* Белые участки становятся прозрачными, темные остаются */
                    element.style.isolation = 'isolate'; /* Изолируем эффект смешивания */
                } else {
                    element.style.backgroundImage = 'none';
                    element.style.background = '#555'; /* Тёмно-серое заполнение по умолчанию */
                }
            });
            
            console.log('Цвет заполнения применен только к пролётам:', color);
        }
        
        // Функции для работы с перемещаемым сайдбаром
        function openFloatingEditor(elementType, element, elementData) {
            const sidebar = document.getElementById('floatingEditorSidebar');
            const poleSection = document.getElementById('poleEditorSection');
            const spanSection = document.getElementById('spanEditorSection');
            const wicketSection = document.getElementById('wicketEditorSection');
            const gateSection = document.getElementById('gateEditorSection');
            let spaceSection = document.getElementById('spaceEditorSection');
            
            // Скрываем все секции
            poleSection.style.display = 'none';
            spanSection.style.display = 'none';
            wicketSection.style.display = 'none';
            gateSection.style.display = 'none';
            if (spaceSection) spaceSection.style.display = 'none';
            
            if (elementType === 'pole') {
                selectedPole = elementData;
                selectedPoleElement = element;
                
                // Показываем секцию для столбов
                poleSection.style.display = 'block';
                const title = document.getElementById('editorTitle');
                if (title) title.textContent = 'Редактирование столба';
                
                // Устанавливаем текущую высоту столба
                const heightInput = document.getElementById('poleHeightEditor');
                heightInput.value = elementData.height || 8;
                
                // Обновляем состояние кнопок цвета блоков
                updateBlockColorButtonStates(globalBlockColor);
                
                console.log('Открыт редактор столба:', elementData);
            } else if (elementType === 'span') {
                selectedSpan = elementData;
                selectedSpanElement = element;
                
                // Показываем секцию для пролётов
                spanSection.style.display = 'block';
                const title = document.getElementById('editorTitle');
                if (title) title.textContent = 'Редактирование пролёта';
                
                // Устанавливаем текущие значения пролёта
                const widthInput = document.getElementById('spanWidthEditor');
                const rowsInput = document.getElementById('spanRowsEditor');
                
                widthInput.value = (elementData.length || 250) / 100;
                rowsInput.value = elementData.rows || 1;
                
                // Обновляем состояние кнопок цветов
                const currentColor = elementData.fillColor || globalFillColor || 'gray';
                updateColorButtonStates('span', currentColor);
                
                // Обновляем состояние кнопок цвета блоков
                updateBlockColorButtonStates(globalBlockColor);
                
                console.log('Открыт редактор пролёта:', elementData);
            } else if (elementType === 'wicket') {
                selectedWicket = elementData;
                selectedWicketElement = element;
                
                // Показываем секцию для калиток
                wicketSection.style.display = 'block';
                const title = document.getElementById('editorTitle');
                if (title) title.textContent = 'Редактирование калитки';
                
                // Устанавливаем текущие значения калитки
                const widthInput = document.getElementById('wicketWidthEditor');
                widthInput.value = (elementData.width || 100) / 100;
                
                // Обновляем состояние кнопок цветов
                const currentColor = elementData.fillColor || 'gray';
                updateColorButtonStates('wicket', currentColor);
                
                console.log('Открыт редактор калитки:', elementData);
            } else if (elementType === 'gate') {
                selectedGate = elementData;
                selectedGateElement = element;
                
                // Показываем секцию для ворот
                gateSection.style.display = 'block';
                const title = document.getElementById('editorTitle');
                if (title) title.textContent = 'Редактирование ворот';
                
                // Устанавливаем текущие значения ворот
                const widthInput = document.getElementById('gateWidthEditor');
                widthInput.value = (elementData.width || 400) / 100;
                
                // Обновляем состояние кнопок цветов
                const currentColor = elementData.fillColor || 'gray';
                updateColorButtonStates('gate', currentColor);
                
                console.log('Открыт редактор ворот:', elementData);
            } else if (elementType === 'space') {
                selectedSpace = elementData;
                selectedSpaceElement = element;
                if (!spaceSection) {
                    // Создадим секцию при первом использовании (на случай отсутствия в разметке)
                    spaceSection = document.createElement('div');
                    spaceSection.id = 'spaceEditorSection';
                    spaceSection.innerHTML = `
                        <div class="form-group" style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #666; font-size: 14px;">Ширина проёма (м):</label>
                            <div class="number-input-group" style="display: flex; align-items: center; gap: 8px;">
                                <button class="number-btn" onclick="changeSpaceWidth(-0.5)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">-</button>
                                <input type="number" id="spaceWidthEditor" value="1.0" step="0.5" min="0.5" style="width: 50px; height: 28px; text-align: center; background: #f9f9f9; border: 1px solid #ddd; color: #333; border-radius: 4px; font-size: 14px; -webkit-appearance: none; -moz-appearance: textfield;">
                                <button class="number-btn" onclick="changeSpaceWidth(0.5)" style="width: 28px; height: 28px; background: #ff6600; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">+</button>
                            </div>
                        </div>
                    `;
                    const sidebar = document.getElementById('floatingEditorSidebar');
                    sidebar.appendChild(spaceSection);
                }
                spaceSection.style.display = 'block';
                const title = document.getElementById('editorTitle');
                if (title) title.textContent = 'Редактирование проёма';
                const widthInput = document.getElementById('spaceWidthEditor');
                widthInput.value = (elementData.width || 100) / 100;
                console.log('Открыт редактор проёма:', elementData);
            }
            
            // Показываем сайдбар
            sidebar.style.display = 'block';
            
            // Добавляем функциональность перетаскивания
            setupDraggableSidebar(sidebar);
        }
        
        function closeFloatingEditor() {
            const sidebar = document.getElementById('floatingEditorSidebar');
            sidebar.style.display = 'none';
            
            // Убираем выделение со всех элементов
            if (selectedPoleElement) {
                selectedPoleElement.classList.remove('selected');
                removeSelectionHighlight(selectedPoleElement);
            }
            if (selectedSpanElement) {
                selectedSpanElement.classList.remove('selected');
                removeSelectionHighlight(selectedSpanElement);
            }
            if (selectedGateElement) {
                selectedGateElement.classList.remove('selected');
                removeSelectionHighlight(selectedGateElement);
            }
            if (selectedWicketElement) {
                selectedWicketElement.classList.remove('selected');
                removeSelectionHighlight(selectedWicketElement);
            }
            
            selectedPole = null;
            selectedPoleElement = null;
            selectedSpan = null;
            selectedSpanElement = null;
            selectedGate = null;
            selectedGateElement = null;
            selectedWicket = null;
            selectedWicketElement = null;
            
            console.log('Перемещаемый редактор закрыт');
        }
        
        function applyChanges() {
            if (selectedPole) {
                applyPoleChanges();
            } else if (selectedSpan) {
                applySpanChanges();
            }
        }
        
        function applyPoleChanges() {
            if (!selectedPole) return;
            
            const heightInput = document.getElementById('poleHeightEditor');
            const newHeight = parseInt(heightInput.value) || 8;
            
            // Применяем изменения высоты столба
            changePoleHeight(newHeight - (selectedPole.height || 8));
        }
        
        function applySpanChanges() {
            if (!selectedSpan) return;
            
            const widthInput = document.getElementById('spanWidthEditor');
            const rowsInput = document.getElementById('spanRowsEditor');
            
            const newWidth = parseFloat(widthInput.value) || 2.5;
            const newRows = parseInt(rowsInput.value) || 1;
            const newColor = document.getElementById('spanColorEditor').value;
            
            // Обновляем данные пролёта
            selectedSpan.length = newWidth * 100;
            selectedSpan.rows = newRows;
            
            // Применяем новый цвет заполнения
            if (newColor !== globalFillColor) {
                changeFillColor(newColor);
            }
            
            // Очищаем старые текстуры при изменении ширины
            if (selectedSpan.textures && selectedSpan.textures.length > 0) {
                const oldBlockCount = Math.floor((selectedSpan.length || 250) / 50);
                const newBlockCount = Math.floor(newWidth * 100 / 50);
                if (oldBlockCount !== newBlockCount) {
                    selectedSpan.textures = []; // Сбрасываем текстуры для перегенерации
                    selectedSpan.peakTextures = []; // Сбрасываем текстуры крышек для перегенерации
                }
            }
            
            // Проверяем, нужно ли применить ко всем пролётам
            const applyToAll = document.getElementById('applyToAllSpans').checked;
            if (applyToAll) {
                project.elements.forEach((element, index) => {
                    if (element.type === 'panel') {
                        element.length = newWidth * 100;
                        element.rows = newRows;
                        
                        // Очищаем текстуры для перегенерации
                        if (element.textures && element.textures.length > 0) {
                            const oldBlockCount = Math.floor((element.length || 250) / 50);
                            const newBlockCount = Math.floor(newWidth * 100 / 50);
                            if (oldBlockCount !== newBlockCount) {
                                element.textures = [];
                                element.peakTextures = []; // Сбрасываем текстуры крышек для перегенерации
                            }
                        }
                        
                        console.log('Обновлен пролёт', index, ':', element.type, 'на', { newWidth, newRows });
                    }
                });
            }
            
            console.log('Применены изменения пролёта:', { newWidth, newRows });
            
            // Перерисовываем элементы
            renderFenceElements();
        }
        
        // Настройка перетаскивания сайдбара
        function setupDraggableSidebar(sidebar) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            sidebar.addEventListener('mousedown', function(e) {
                if (e.target.closest('input, button, select, label')) return; // Не перетаскиваем при клике на элементы управления
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = sidebar.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;
                
                sidebar.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const newLeft = startLeft + deltaX;
                const newTop = startTop + deltaY;
                
                // Ограничиваем перемещение в пределах экрана
                const maxLeft = window.innerWidth - sidebar.offsetWidth;
                const maxTop = window.innerHeight - sidebar.offsetHeight;
                
                sidebar.style.left = Math.max(0, Math.min(maxLeft, newLeft)) + 'px';
                sidebar.style.top = Math.max(0, Math.min(maxTop, newTop)) + 'px';
                sidebar.style.right = 'auto';
                sidebar.style.transform = 'none';
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    sidebar.style.cursor = 'move';
                }
            });
        }
        
        // Функции управления видом
        function toggleView() {
            is3D = !is3D;
            drawScene();
        }
        
        function zoomIn() {
            zoom = Math.min(5.0, zoom * 1.2);
            updateZoomIndicator();
            
            // Обновляем трансформацию контейнера забора
            const fenceContainer = document.getElementById('fenceContainer');
            if (fenceContainer) {
                applyTransformToContainer(fenceContainer);
            }
            
            drawScene();
        }
        
        function zoomOut() {
            zoom = Math.max(0.1, zoom / 1.2);
            updateZoomIndicator();
            
            // Обновляем трансформацию контейнера забора
            const fenceContainer = document.getElementById('fenceContainer');
            if (fenceContainer) {
                applyTransformToContainer(fenceContainer);
            }
            
            drawScene();
        }
        
        function resetView() {
            zoom = 1;
            panX = 0;
            panY = 0;
            updateZoomIndicator();
            
            // Обновляем трансформацию контейнера забора
            const fenceContainer = document.getElementById('fenceContainer');
            if (fenceContainer) {
                applyTransformToContainer(fenceContainer);
            }
            
            drawScene();
        }
        
        // Переключатель день/ночь
        const dayNightSwitch = document.getElementById('dayNightSwitch');
        let isNightMode = false;

        // Показ/скрытие меню добавления отрезка
        function openEpisodeMenu() {
            const section = document.getElementById('episodeAddSection');
            if (section) section.style.display = 'block';
        }

        function incrementEpisodeLength(delta) {
            const el = document.getElementById('episodeLength');
            if (!el) return;
            const cur = parseFloat(el.value) || 10;
            const next = Math.max(0.5, cur + delta);
            el.value = next.toFixed(1);
        }

        function incrementEpisodeSpanWidth(delta) {
            const el = document.getElementById('poleDistance');
            if (!el) return;
            const cur = parseFloat(el.value) || 2.5;
            const next = Math.max(0, cur + delta);
            el.value = next.toFixed(1);
        }

        function incrementEpisodePoleHeight(delta) {
            const el = document.getElementById('episodePoleHeight');
            if (!el) return;
            const cur = parseInt(el.value) || 8;
            const next = Math.max(1, Math.min(20, cur + delta));
            el.value = next.toString();
        }
        
        function toggleDayNight() {
            isNightMode = !isNightMode;
            
            if (isNightMode) {
                document.body.classList.add('night-mode');
                dayNightSwitch.textContent = '🌙';
                console.log('Переключен в ночной режим');
            } else {
                document.body.classList.remove('night-mode');
                dayNightSwitch.textContent = '☀️';
                console.log('Переключен в дневной режим');
            }
            
            // Перерисовываем сцену с новым фоном
            drawScene();
            renderFenceElements();
        }

        // Функция обновления прозрачности линии земли
        function updateGroundLineOpacity(hasBackgroundImage) {
            const groundLine = document.getElementById('groundLine');
            if (groundLine) {
                if (hasBackgroundImage) {
                    // 80% прозрачность после загрузки фото
                    groundLine.classList.add('with-background');
                    groundLine.style.background = 'linear-gradient(to bottom, rgba(74, 74, 74, 0.8) 0%, rgba(59, 47, 34, 0.8) 45%, rgba(43, 34, 15, 0.8) 100%)';
                    console.log('Прозрачность линии земли установлена на 80% (с фоном)');
                } else {
                    // 50% прозрачность по умолчанию
                    groundLine.classList.remove('with-background');
                    groundLine.style.background = 'linear-gradient(to bottom, rgba(74, 74, 74, 0.5) 0%, rgba(59, 47, 34, 0.5) 45%, rgba(43, 34, 15, 0.5) 100%)';
                    console.log('Прозрачность линии земли установлена на 50% (без фона)');
                }
            }
        }

        // Загрузка пользовательского фона
        function openBackgroundUpload() {
            const input = document.getElementById('bgUploadInput');
            if (input) input.click();
        }

        const bgUploadInput = document.getElementById('bgUploadInput');
        if (bgUploadInput) {
            bgUploadInput.addEventListener('change', (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = () => {
                    const img = new Image();
                    img.onload = () => {
                        customBackgroundImage = img;
                        userBackgroundImage = img; // Устанавливаем для других функций
                        
                        // Изменяем прозрачность линии земли на 80% после загрузки фото
                        updateGroundLineOpacity(true);
                        
                        drawScene();
                        renderFenceElements();
                        
                        console.log('Пользовательское фоновое изображение загружено, прозрачность линии земли увеличена до 80%');
                    };
                    img.src = reader.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Обработчик для переключателя день/ночь
        if (dayNightSwitch) {
            dayNightSwitch.addEventListener('click', toggleDayNight);
        }
        
        // Инициализация при загрузке страницы
        window.addEventListener('load', () => {
            console.log('Страница загружена, начинаем инициализацию...');
            // Небольшая задержка для полной готовности DOM
            setTimeout(() => {
            init();
            setupRotationControls();
            }, 100);
        });
    </script>
</body>
</html>
